
---

### 3장: 함수와 모듈 (프로그램을 작게 나누어 효율적으로 관리하기)

- 파이썬에서 함수를 정의하고, 여러 파일에 나눠서 코드를 관리했던 경험이 있을 겁니다. 
- C 언어에서도 마찬가지로 **함수(Function)** 는 특정 작업을 수행하는 코드 덩어리이며, 코드를 재사용하고 관리하기 쉽게 만들어 줍니다. 
- 그리고 여러 함수들을 그룹화하여 파일로 나누어 관리하는 것을 **모듈화**라고 합니다. 
- 파이썬과 비슷하지만, C 언어에서는 함수가 데이터를 처리하는 방식과 모듈을 구성하는 방식에서 중요한 차이가 있습니다.

---
#### 3.1 함수의 정의 및 호출: C 언어에서 함수 만들기

함수는 특정 작업을 수행하는 코드의 묶음입니다. C 언어에서 함수는 다음과 같은 요소들을 가집니다.

- **반환 타입(Return Type):** 함수가 작업을 마친 후 돌려줄 값의 데이터 타입입니다. 아무 값도 돌려주지 않을 경우 `void`를 사용합니다.
- **함수 이름(Function Name):** 함수의 목적을 나타내는 이름입니다.
- **매개변수(Parameters):** 함수가 작업을 수행하는 데 필요한 입력 값들입니다. 없으면 비워둡니다.
- 그리고 위의 요소들을 합쳐서 **"함수 시그니처(Function Signatrue)"** 라고 말합니다.

- **함수 정의 예시:**

```c
// int: 이 함수는 정수 값을 반환합니다.
// add: 함수의 이름입니다.
// (int a, int b): 두 개의 정수형 매개변수를 받습니다.
int add(int a, int b) {
    int sum = a + b; // 매개변수 a와 b를 더하여 sum 변수에 저장
    return sum;      // sum 값을 반환
}

// void: 이 함수는 아무 값도 반환하지 않습니다.
// print_message: 함수의 이름입니다.
// (void): 어떤 매개변수도 받지 않습니다.
void print_message(void) {
    printf("Hello from a C function!\n");
}
```

- **함수 호출:** 정의된 함수를 사용하는 것은 파이썬과 동일하게 함수 이름 뒤에 괄호를 붙이고 필요한 인자(argument)를 전달합니다.

```c
int main() {
    int result = add(5, 3); // add 함수 호출, 8이 반환되어 result에 저장
    printf("5 + 3 = %d\n", result); // 출력: 5 + 3 = 8

    print_message(); // print_message 함수 호출
    return 0;
}
```

- **함수 원형(Function Prototype):** 
	- C 언어에서는 함수를 사용하기 전에 컴파일러에게 "이러한 함수가 나중에 나올 것이다"라고 미리 알려주는 **함수 원형(Function Prototype)**을 선언해 주어야 합니다. 
	- 주로 `main` 함수나 다른 함수들이 호출하기 전에 함수의 정의가 없을 때 필요합니다. 파이썬은 코드를 위에서 아래로 읽어나가며 함수가 정의되면 바로 사용할 수 있지만, C는 컴파일 방식이기 때문에 모든 정보를 미리 알고 있어야 합니다.

```c
#include <stdio.h>

// 함수 원형 선언: add 함수가 int 타입을 반환하고 int 매개변수 두 개를 받는다고 미리 알려줍니다.
int add(int a, int b);

int main() {
    int result = add(10, 20); // main 함수가 add 함수보다 먼저 정의되었으므로 원형이 필요합니다.
    printf("Result: %d\n", result);
    return 0;
}

// add 함수의 실제 정의는 main 함수 뒤에 위치할 수 있습니다.
int add(int a, int b) {
    return a + b;
}
```

---

#### 3.2 매개변수 전달 방식: '값' 복사와 '주소' 복사

파이썬에서는 변수를 함수에 전달할 때 주로 '객체 참조'가 전달됩니다. 하지만 C 언어에서는 매개변수를 함수에 전달하는 두 가지 주요 방식이 있습니다.

- **값에 의한 호출 (Call by Value):** 함수에 인자를 전달할 때, **인자의 '값'을 복사해서 전달**합니다. 함수 내부에서 이 복사된 값을 아무리 변경해도, 원본 변수의 값은 전혀 영향을 받지 않습니다. 파이썬에서 정수나 문자열 같은 불변 객체를 함수에 전달하는 것과 유사합니다.

    **예시: `swap` 함수가 제대로 동작하지 않는 경우**
    `swap` 함수를 만들어서 두 변수의 값을 서로 바꾸려고 한다고 가정해 봅시다.
    
    ```c
    #include <stdio.h>
    
    // 값에 의한 호출 방식으로 두 정수를 교환하려는 함수
    void swap_by_value(int a, int b) {
        int temp = a;
        a = b;
        b = temp;
        printf("함수 내부: a = %d, b = %d\n", a, b);
    }
    
    int main() {
        int x = 10;
        int y = 20;
    
        printf("함수 호출 전: x = %d, y = %d\n", x, y); // x=10, y=20
    
        swap_by_value(x, y); // x의 값(10)과 y의 값(20)이 각각 a와 b로 복사되어 전달됨
    
        printf("함수 호출 후: x = %d, y = %d\n", x, y); // 여전히 x=10, y=20
        return 0;
    }
    ```
    
    **결과:**
    
    ```
    함수 호출 전: x = 10, y = 20
    함수 내부: a = 20, b = 10
    함수 호출 후: x = 10, y = 20
    ```
    
    **설명:** `swap_by_value` 함수 내부에서 `a`와 `b`의 값이 성공적으로 바뀌었지만, 이는 `main` 함수에서 넘어온 `x`와 `y`의 **복사본**일 뿐입니다. 함수가 종료되면 `a`와 `b`는 사라지고, `main` 함수의 `x`와 `y`는 원래 값을 그대로 유지합니다. 파이썬에서 `x = 10; y = 20; def my_func(a, b): a, b = b, a; my_func(x, y)`와 같이 코드를 작성했을 때 `x`와 `y`가 변하지 않는 것과 같은 이치입니다.
    

---

#### 3.3 재귀 함수: 스스로를 호출하는 함수

- **재귀 함수(Recursive Function)** 는 함수가 자기 자신을 다시 호출하여 작업을 수행하는 함수를 말합니다. 
- 특정 문제를 더 작고 유사한 문제로 나눌 수 있을 때 유용하게 사용됩니다. 
	- 파이썬에서도 재귀 함수를 사용해 봤을 것입니다.

**예시: 팩토리얼 계산

```c
int factorial(int n) {
    // 재귀 호출의 종료 조건 (Base Case)
    if (n == 0) {
        return 1;
    }
    // 재귀 호출 (Recursive Call)
    else {
        return n * factorial(n - 1);
    }
}

int main() {
    printf("5! = %d\n", factorial(5)); // 출력: 5! = 120
    return 0;
}
```

재귀 함수는 코드를 간결하게 만들 수 있지만, 너무 깊은 재귀 호출은 스택 오버플로우를 발생시킬 수 있으므로 주의해야 합니다.

---

#### 3.4 헤더 파일과 소스 파일 분리: 코드의 모듈화와 관리

- 파이썬에서 `import` 문을 사용해서 다른 파일에 있는 함수나 클래스를 가져와 사용했듯이, C 언어에서도 코드를 여러 파일로 나누어 관리합니다.
- 이를 통해 코드의 가독성을 높이고, 유지보수를 쉽게 하며, 여러 개발자가 협업할 때 충돌을 줄일 수 있습니다.


- C 언어에서 모듈화를 할 때는 주로 `.h` (헤더 파일)과 `.c` (소스 파일)을 사용합니다.
	- **`.h` (헤더 파일):** 주로 **함수의 원형(prototype)**, 매크로 정의(`\#define`), 구조체 정의 등 **선언(Declaration)** 부분만 포함합니다. 이 파일은 다른 C 소스 파일에서 사용할 기능 목록을 '미리보기'처럼 제공합니다.
	- **`.c` (소스 파일):** 헤더 파일에 선언된 **함수의 실제 구현(Definition)** 과 변수 초기화 등을 포함합니다.


##### 빌드 과정과 파일 의존성: C 프로그램이 만들어지는 과정

C 언어 프로젝트를 '빌드(Build)'한다는 것은 소스 코드 파일들(`*.c`)을 실행 가능한 프로그램으로 만드는 과정을 의미합니다. 이 과정은 크게 **전처리(Preprocessing)**, **컴파일(Compiling)**, **어셈블(Assembling)**, **링킹(Linking)**의 단계를 거칩니다.

1. **전처리 (Preprocessing):**
    - `#include` 지시자를 만나면 해당 파일의 내용을 현재 파일에 복사합니다.
    - `#define` 같은 매크로를 실제 값이나 코드로 치환합니다.
    - `#ifndef` 같은 조건부 컴파일 지시자를 처리합니다.
    - 결과물은 확장된 소스 파일(`*.i`)이 됩니다.
        
2. **컴파일 (Compiling):**
    - 전처리된 소스 파일(`*.i`)을 컴파일러가 읽고, 문법 오류를 검사하며, 해당 아키텍처에 맞는 **어셈블리 코드(`*.s`)**로 변환합니다.
        
3. **어셈블 (Assembling):**
    - 어셈블리 코드(`*.s`)를 어셈블러가 읽고, 컴퓨터가 직접 실행할 수 있는 **목적 코드(`*.o` 또는 `*.obj`)**로 변환합니다. 목적 코드는 아직 완전히 독립적인 실행 파일은 아니고, 다른 목적 코드나 라이브러리와 연결되어야 합니다.
        
4. **링킹 (Linking):**
    - 링커가 여러 목적 코드 파일(`*.o`)들과 필요한 외부 라이브러리(예: `stdio.h`의 `printf` 실제 구현 코드)들을 하나로 묶어서 최종 **실행 파일(`*.exe` 또는 `a.out`)**을 만듭니다. 이 단계에서 모든 함수 호출이 실제 함수 정의와 연결됩니다.

**각 `.c` 파일과 `.h` 파일의 의존성:**
- **`.c` 파일은 `.h` 파일을 포함합니다 (`#include`).**
    - `main.c`는 `calculator.h`를 포함하여 `add`와 `subtract` 함수의 존재를 알고 사용합니다.
    - `calculator.c`는 `calculator.h`를 포함하여 자신이 구현하는 함수의 원형이 제대로 일치하는지 확인합니다.
        
- **컴파일러는 각 `.c` 파일을 독립적으로 컴파일하여 `.o` 파일을 만듭니다.**
    - `main.c`는 `main.o`가 됩니다.
    - `calculator.c`는 `calculator.o`가 됩니다.
    - 이때 컴파일러는 `.c` 파일이 `#include`한 `.h` 파일의 내용을 참조하여 함수 원형 등을 확인합니다.
        
- **링커가 모든 `.o` 파일과 라이브러리를 연결합니다.**
    - `main.o`에서 `add` 함수를 호출하는 부분은 링킹 단계에서 `calculator.o`에 있는 `add` 함수의 실제 코드와 연결됩니다.
        

- 이러한 모듈화와 빌드 과정은 대규모 C 언어 프로젝트를 효율적으로 관리하고 컴파일 속도를 최적화하는 데 필수적인 개념입니다. 
- 파이썬의 모듈 임포트가 런타임에 동적으로 이루어지는 것과 달리, C 언어는 컴파일 시점에 모든 것이 정적으로 연결된다는 점을 기억하는 것이 중요합니다.



**예시: `calculator.h`와 `calculator.c`로 기능 분리**

**`calculator.h` (헤더 파일):**
```c
#ifndef CALCULATOR_H
#define CALCULATOR_H

// add 함수의 원형 선언
int add(int a, int b);

// subtract 함수의 원형 선언
int subtract(int a, int b);

#endif // CALCULATOR_H
```

**`calculator.c` (소스 파일):**
```c
#include "calculator.h" // 자신이 구현하는 함수의 선언을 포함합니다.

// add 함수의 실제 구현
int add(int a, int b) {
    return a + b;
}

// subtract 함수의 실제 구현
int subtract(int a, int b) {
    return a - b;
}
```

**`main.c` (메인 프로그램 파일):**
```c
#include <stdio.h>
#include "calculator.h" // calculator.h에 선언된 함수들을 사용하기 위해 포함합니다.

int main() {
    int sum = add(10, 5);
    int diff = subtract(10, 5);
    printf("Sum: %d\n", sum);     // 출력: Sum: 15
    printf("Diff: %d\n", diff);   // 출력: Diff: 5
    return 0;
}
```

##### `#include` 지시자: 파일 포함하기

- C 언어에서 `#include`는 다른 파일의 내용을 현재 파일에 복사해서 붙여넣는 역할을 하는 **전처리기 지시자**입니다.
	- `#include <stdio.h>`: `<>`는 **표준 라이브러리** 경로에서 `stdio.h`를 찾으라는 의미입니다. `stdio.h`는 `printf` 같은 표준 입출력 함수들의 원형이 정의된 파일입니다.
	- `#include "calculator.h"`: `""`는 **현재 프로젝트 폴더** 또는 지정된 경로에서 `calculator.h`를 찾으라는 의미입니다. 우리가 직접 만든 헤더 파일을 포함할 때 사용합니다.
    
##### `#pragma once`와 `#ifndef / #define / #endif`: 중복 포함 방지

- `#include`는 단순히 파일 내용을 복사해오기 때문에, 같은 헤더 파일이 여러 번 포함되면 **중복 정의 오류**가 발생할 수 있습니다. 이를 막기 위해 사용하는 것이 **헤더 가드(Header Guard)** 입니다.
- **`#ifndef / #define / #endif`:** 가장 일반적인 방법입니다.
    - `#ifndef CALCULATOR_H`: `CALCULATOR_H`라는 매크로가 정의되어 있지 않다면...
    - `#define CALCULATOR_H`: `CALCULATOR_H`를 정의하고...
    - ... (헤더 파일 내용) ...
    - `#endif`: `ifndef` 블록의 끝을 나타냅니다. 이 구조 덕분에 `calculator.h`가 여러 번 `#include`되더라도, 처음 한 번만 내용이 포함되고 두 번째부터는 `CALCULATOR_H`가 이미 정의되어 있으므로 스킵됩니다.
        
- **`#pragma once`:** 최근에는 `#pragma once`라는 더 간결한 지시자를 많이 사용합니다. 이 지시자를 헤더 파일 맨 위에 한 줄만 추가하면, 컴파일러가 해당 헤더 파일을 **단 한 번만 포함**하도록 보장해 줍니다. 이는 `ifndef` 방식보다 더 짧고 오류 발생 가능성이 적기 때문에 권장됩니다.
    ```c
    // calculator.h 파일 내부
    #pragma once // 이 헤더 파일은 딱 한 번만 포함됩니다.
    
    int add(int a, int b);
    int subtract(int a, int b);
    ```
    
    **왜 `#pragma once`를 사용해야 하는가?** 주로 대규모 프로젝트에서 헤더 파일 간의 복잡한 의존성으로 인해 한 헤더 파일이 여러 번 포함되는 상황을 방지하기 위함입니다. 이는 컴파일 시간을 줄이고, 특히 함수의 중복 정의 오류를 사전에 방지하여 개발 효율성을 높이는 데 필수적입니다.
    



---

### 4장: 배열과 문자열 (메모리 연속성 이해)

- 파이썬에서는 데이터를 묶어서 다룰 때 **리스트(list)** 나 **튜플(tuple)** 을 주로 사용해왔을 것입니다. 
- 이들은 매우 유연해서 여러 종류의 데이터를 담을 수 있고 크기도 자유롭게 조절할 수 있습니다. 
	- 하지만 C 언어에서는 데이터 묶음을 다루는 방식이 좀 더 엄격합니다. 
- 바로 **배열(Array)** 이라는 개념인데, C 언어의 배열은 메모리에 데이터가 어떻게 저장되는지 명확히 이해하는 데 중요한 역할을 합니다. 
- 특히, 문자열을 다루는 방식에서 파이썬과 큰 차이를 보입니다.

---
#### 4.1 배열: 같은 타입의 데이터를 줄줄이 저장하기

- C 언어에서 **배열**은 **동일한 데이터 타입**의 값들을 **메모리에 연속적으로** 저장하는 자료 구조입니다. 
- 파이썬의 리스트와 달리, C 배열은 한 번 선언되면 **크기가 고정**되고, 모든 요소는 **같은 타입**이어야 합니다.

- **배열 선언 및 초기화:**
	- 배열을 사용하려면 먼저 배열의 타입, 이름, 그리고 크기를 명시하여 선언해야 합니다.

```c
// 정수형 배열 numbers를 선언하고, 5개의 int를 저장할 공간을 예약합니다.
int numbers[5];

// 배열 선언과 동시에 초기화 (초기화하지 않으면 '쓰레기 값'이 들어있을 수 있습니다)
int scores[3] = {85, 92, 78};

// 크기를 명시하지 않고 초기화하면, 초기화 리스트의 개수에 따라 크기가 결정됩니다.
int ages[] = {20, 22, 25, 21}; // 이 배열의 크기는 4가 됩니다.
```

- **배열 요소 접근:**
	- 배열의 각 요소는 **인덱스(index)** 를 통해 접근합니다. 파이썬과 마찬가지로 **인덱스는 0부터 시작**합니다.

```c
int data[4] = {10, 20, 30, 40};

printf("첫 번째 요소: %d\n", data[0]); // 출력: 첫 번째 요소: 10
printf("세 번째 요소: %d\n", data[2]); // 출력: 세 번째 요소: 30

data[1] = 25; // 두 번째 요소의 값을 20에서 25로 변경
printf("변경된 두 번째 요소: %d\n", data[1]); // 출력: 변경된 두 번째 요소: 25
```

- **다차원 배열:**
	- 2차원 배열은 행(row)과 열(column)을 가지는 표 형태로 데이터를 저장할 때 사용하며, 3차원 이상의 다차원 배열도 가능합니다.

```c
// 2행 3열의 2차원 정수 배열 선언 및 초기화
int matrix[2][3] = {
    {1, 2, 3}, // 첫 번째 행
    {4, 5, 6}  // 두 번째 행
};

printf("matrix[0][1]: %d\n", matrix[0][1]); // 출력: 2
printf("matrix[1][2]: %d\n", matrix[1][2]); // 출력: 6
```


----
#### 4.2 문자열: C 언어에서 문자의 배열 다루기

- 파이썬에서 문자열(`str`)은 자체적인 객체 타입으로 다양한 편리한 메서드를 제공했습니다. 
- 하지만 C 언어에서 **문자열은 기본적으로 `char` 타입의 배열**로 다룹니다. 
- 그리고 C 문자열의 아주 중요한 특징은 문자열의 끝을 나타내는 특별한 문자, 바로 **널 종료 문자(`\0`)** 가 항상 마지막에 포함되어야 한다는 것입니다.

- **C 언어에서 문자열의 표현:**

```c
// 문자열 선언 및 초기화 방법 1: char 배열로 초기화 (가장 일반적)
char greeting[6] = {'H', 'e', 'l', 'l', 'o', '\0'}; // 널 종료 문자 포함

// 문자열 선언 및 초기화 방법 2: 문자열 리터럴로 초기화 (가장 편리)
char message[] = "Hello, C!"; // 컴파일러가 자동으로 널 종료 문자를 추가하고 배열 크기를 계산합니다.

// 읽기 전용 문자열 포인터 (나중에 포인터 장에서 더 자세히 배웁니다)
const char* name = "홍길동";
```

- `"Hello, C!"`와 같은 문자열 리터럴을 사용하면 컴파일러가 자동으로 마지막에 `\0` 문자를 추가해 줍니다. 
- 따라서 `"Hello"`라는 문자열을 저장하려면 실제로는 6바이트(5글자 + `\0`)의 공간이 필요합니다.

- **`char` 배열과 `string` 객체의 차이 (파이썬과 비교):**

| 특징      | 파이썬의 `string` 객체                               | C 언어의 `char` 배열 (문자열)              |
| ------- | ---------------------------------------------- | ---------------------------------- |
| **타입**  | 불변(immutable) 객체                               | `char` 타입의 배열. 내용은 변경 가능하지만 크기는 고정 |
| **메모리** | 자동으로 관리 (가비지 컬렉션), 내부 구조는 복잡                   | 연속된 메모리 공간에 저장, 개발자가 직접 관리         |
| **크기**  | 동적으로 변함, `len()` 함수로 길이 확인                     | 선언 시 고정, 실제 문자열 길이는 `\0`까지의 길이     |
| **종료**  | 특정 종료 문자 없음                                    | 반드시 **널 종료 문자(`\0`)**로 끝남          |
| **메서드** | `replace()`, `split()`, `upper()` 등 풍부한 내장 메서드 | 직접적인 내장 메서드 없음, 라이브러리 함수 사용        |

---

- C 언어의 배열과 문자열은 파이썬의 리스트나 문자열 객체보다 훨씬 '로우 레벨'에 가깝습니다.
- 메모리에 데이터가 어떻게 연속적으로 저장되고, 문자열이 어떻게 널 종료 문자로 끝나는지 이해하는 것은 C 언어를 통해 시스템을 더 깊이 제어하고 효율적인 코드를 작성하는 데 필수적인 지식입니다. 
- 처음에는 불편하게 느껴질 수 있지만, 이러한 제어권 덕분에 C 언어가 갖는 강력한 성능과 유연성을 이해하게 될 것입니다.



---

### 5장: 포인터 (C 언어의 핵심, 메모리 직접 제어)

- 이전에 파이썬과 C 언어의 가장 큰 차이점으로 **메모리 관리 방식**을 언급했습니다. 
- 파이썬이 자동으로 메모리를 관리해주는 반면, C 언어는 개발자가 직접 메모리를 제어해야 합니다. 
- 이 직접적인 제어를 가능하게 하는 C 언어의 가장 강력하고 핵심적인 개념이 바로 **포인터(Pointer)** 입니다. 
- 포인터는 C 언어의 '심장'과 같아서, 이를 이해하면 C 언어의 동작 원리를 깊이 파악하고 훨씬 효율적이며 강력한 프로그램을 만들 수 있습니다.

---

#### 5.1. 포인터의 기본 개념: 메모리 주소를 가리키는 변수

- 우리 컴퓨터의 메모리는 마치 번지수가 있는 수많은 사물함과 같습니다. 각 사물함은 고유한 주소(번지수)를 가지고 있고, 그 안에 데이터를 저장합니다.
	- **포인터(Pointer)** 란 바로 이 **메모리 주소를 값으로 저장하는 변수**입니다.
	- 일반 변수가 특정 데이터를 직접 저장한다면, 포인터 변수는 **데이터가 저장된 '위치'(주소)** 를 저장하는 것입니다.

- 포인터 변수를 선언할 때는 `*` 기호를 사용하여 해당 포인터가 어떤 타입의 데이터 주소를 가리킬 것인지를 명시합니다.

```c
int num = 10;       // num이라는 정수형 변수에 값 10을 저장합니다.
int *ptr_num;       // ptr_num이라는 '정수형 포인터' 변수를 선언합니다.
                    // 이 포인터는 정수형 변수의 주소를 저장할 수 있습니다.

ptr_num = &num;     // &num은 num 변수의 메모리 주소를 의미합니다.
                    // ptr_num에 num 변수의 주소를 할당합니다.
```

여기서 사용된 두 가지 중요한 연산자가 있습니다:
- **`&` (주소 연산자 - Address-of Operator):** 변수 앞에 붙으면 그 **변수의 메모리 주소**를 반환합니다.
- **`*` (역참조 연산자 - Dereference Operator):** 포인터 변수 앞에 붙으면 포인터가 **가리키는 주소에 저장된 '값'** 을 가져옵니다.

```c
printf("num의 값: %d\n", num);         // 출력: num의 값: 10
printf("num의 주소: %p\n", &num);       // 출력: num의 주소: (예: 0x7ffee23c8a9c)
printf("ptr_num의 값 (주소): %p\n", ptr_num); // 출력: ptr_num의 값 (주소): (예: 0x7ffee23c8a9c)
printf("ptr_num이 가리키는 값: %d\n", *ptr_num); // 출력: ptr_num이 가리키는 값: 10

// 포인터를 통해 값을 변경할 수도 있습니다.
*ptr_num = 20; // ptr_num이 가리키는 곳(num의 주소)의 값을 20으로 변경
printf("num의 새로운 값: %d\n", num); // 출력: num의 새로운 값: 20
```

---

#### 5.2. 포인터와 배열: 배열의 이름은 곧 주소

- C 언어의 **배열 이름은 곧 배열의 첫 번째 요소의 메모리 주소**를 나타냅니다. 이 개념은 포인터를 이해하는 데 매우 중요합니다.


```c
int scores[3] = {100, 90, 80};

printf("scores[0]의 주소: %p\n", &scores[0]); // scores 배열 첫 번째 요소의 주소
printf("배열 이름 scores의 값: %p\n", scores); // 배열 이름 scores 자체의 값 (첫 번째 요소의 주소)

// 두 주소가 동일하다는 것을 알 수 있습니다.
```

- 이러한 특성 때문에, 배열은 포인터처럼 취급될 수 있으며, 포인터를 사용하여 배열의 요소에 접근할 수도 있습니다.

```c
int numbers[5] = {1, 2, 3, 4, 5};
int *p = numbers; // p는 numbers 배열의 첫 번째 요소 주소를 가리킵니다.

printf("numbers[0] = %d\n", *p);       // p가 가리키는 값: 1
printf("numbers[1] = %d\n", *(p + 1)); // p가 가리키는 다음 메모리 위치의 값: 2
printf("numbers[2] = %d\n", p[2]);     // 포인터를 배열처럼 접근할 수도 있습니다: 3
```

- `*(p + 1)`은 `p`가 가리키는 메모리 주소에서 **`int` 크기만큼 건너뛴 다음 위치**에 있는 값을 의미합니다. 
- 이는 C 언어에서 포인터 연산이 단순한 주소 연산이 아니라, 가리키는 타입의 크기를 고려하여 이루어진다는 중요한 특징을 보여줍니다.

---

#### 5.3. 매개변수 전달 심화: '주소에 의한 호출' 예제 (Call by Reference)

- 이전에 '값에 의한 호출' 예시로 `swap` 함수가 제대로 동작하지 않았던 것을 기억하시나요? 
	- 함수 내에서 인자의 복사본을 변경했기 때문에 원본 변수에는 영향을 미치지 못했습니다.

- 하지만 포인터를 사용하면 함수가 원본 변수의 메모리 주소를 직접 전달받아, 그 주소에 있는 값을 변경할 수 있습니다. 
- 이를 **주소에 의한 호출(Call by Reference)** 이라고 합니다. 
	- 파이썬에서 리스트나 딕셔너리 같은 '가변 객체'를 함수에 전달했을 때 함수 내부에서 변경하면 원본이 바뀌는 것과 유사하다고 볼 수 있습니다.


**예시: `swap` 함수가 제대로 동작하는 경우**
- 이제 포인터를 사용하여 두 변수의 값을 성공적으로 교환하는 `swap` 함수를 만들어 보겠습니다.

```c
#include <stdio.h>

// 주소에 의한 호출 방식으로 두 정수를 교환하는 함수
// 매개변수로 정수형 변수의 '주소'를 받도록 포인터 타입을 사용합니다.
void swap_by_address(int *a_ptr, int *b_ptr) {
    int temp = *a_ptr;  // a_ptr이 가리키는 값(원본 x의 값)을 temp에 저장
    *a_ptr = *b_ptr;    // b_ptr이 가리키는 값(원본 y의 값)을 a_ptr이 가리키는 곳(원본 x)에 저장
    *b_ptr = temp;      // temp에 저장된 값을 b_ptr이 가리키는 곳(원본 y)에 저장

    printf("함수 내부: *a_ptr = %d, *b_ptr = %d\n", *a_ptr, *b_ptr);
}

int main() {
    int x = 10;
    int y = 20;

    printf("함수 호출 전: x = %d, y = %d\n", x, y); // x=10, y=20

    // swap_by_address 함수에 x와 y의 '주소'를 전달합니다.
    swap_by_address(&x, &y);

    printf("함수 호출 후: x = %d, y = %d\n", x, y); // x=20, y=10 (값 교환 성공!)
    return 0;
}
```

**결과:**

```
함수 호출 전: x = 10, y = 20
함수 내부: *a_ptr = 20, *b_ptr = 10
함수 호출 후: x = 20, y = 10
```

**설명:** 
- `main` 함수에서 `swap_by_address`를 호출할 때 `&x`와 `&y`를 전달했습니다. 
- 이는 `x`와 `y` 변수의 **메모리 주소**를 의미합니다. 
- `swap_by_address` 함수는 이 주소들을 `a_ptr`과 `b_ptr`이라는 포인터 변수로 받습니다. 
- 이제 `swap_by_address` 함수 내부에서 `*a_ptr`과 `*b_ptr`을 사용하면, `main` 함수에 있는 원본 `x`와 `y`의 메모리 공간에 직접 접근하여 값을 변경할 수 있게 됩니다. 
- 이것이 C 언어에서 포인터가 제공하는 강력한 '직접 제어' 능력입니다.

---
#### 5.4 포인터로 값 형태 확인해보기

- C 언어에서 **포인터**는 메모리의 특정 위치를 가리킬 수 있는 강력한 도구입니다. 
- 특히, `char*` 포인터는 메모리를 **바이트(byte) 단위**로 접근할 때 유용하게 사용됩니다. 
	- 이는 `char` 타입이 1바이트 크기를 가지기 때문입니다.

- `int` 변수에 `-5`를 저장했을 때, 이 값이 메모리에 어떻게 저장되는지를 `char*` 포인터를 통해 각 바이트별로 확인해 볼 것입니다. 
- 시스템의 엔디안(Endianness)에 따라 바이트의 순서가 다르게 나올 수 있다는 점을 미리 알아두세요. 
	- 이 예시는 대부분의 PC 환경인 **리틀 엔디안(Little-endian)** 을 기준으로 작성됩니다. (리틀 엔디안은 숫자의 최하위 바이트가 가장 낮은 메모리 주소에 저장되는 방식입니다.)

**예시 코드:**

```c
#include <stdio.h> // 표준 입출력 함수 (printf 등)를 사용하기 위해 포함

int main() {
    int num = -5; // int 변수 num에 -5를 저장합니다.
                  // 대부분의 시스템에서 int는 4바이트입니다.

    // int 변수 num의 주소를 char* 타입으로 변환합니다.
    // char* 포인터는 메모리를 1바이트 단위로 접근할 때 사용됩니다.
    char *byte_ptr = (char *)&num;

    printf("int 변수 num의 값: %d\n", num);
    printf("int 변수 num의 주소: %p\n", (void *)&num); // (void*)로 캐스팅하여 주소 출력 형식 통일

    printf("\nnum의 각 바이트 값 (16진수):\n");
    // num이 4바이트라고 가정하고 각 바이트를 순회하며 출력합니다.
    // 대부분의 시스템에서 sizeof(int)는 4입니다.
    for (size_t i = 0; i < sizeof(int); i++) {
        // byte_ptr[i]는 byte_ptr이 가리키는 주소로부터 i번째 바이트를 의미합니다.
        // '%02X'는 16진수로 두 자리 채워서 출력하는 형식 지정자입니다.
        // (unsigned char)로 캐스팅하는 이유는 char가 signed일 경우 -128 등의 값이 제대로 출력되지 않을 수 있기 때문입니다.
        printf("Byte %zu: 0x%02X\n", i, (unsigned char)byte_ptr[i]);
    }

    printf("\nnum의 각 바이트 값 (10진수):\n");
    for (size_t i = 0; i < sizeof(int); i++) {
        // 10진수로 출력합니다.
        printf("Byte %zu: %d\n", i, (unsigned char)byte_ptr[i]);
    }

    return 0;
}
```

**예상되는 출력 (리틀 엔디안 시스템):**

```
int 변수 num의 값: -5
int 변수 num의 주소: 0x7ffeefbff22c (주소는 시스템마다 다름)

num의 각 바이트 값 (16진수):
Byte 0: 0xFB
Byte 1: 0xFF
Byte 2: 0xFF
Byte 3: 0xFF

num의 각 바이트 값 (10진수):
Byte 0: 251
Byte 1: 255
Byte 2: 255
Byte 3: 255
```

**설명:**

1. **`int num = -5;`**: `num` 변수에 정수 `-5`가 저장됩니다. 컴퓨터는 음수를 **2의 보수(Two's Complement)** 형태로 저장합니다. 4바이트(32비트) 정수 `-5`는 16진수로 `0xFFFFFFFB`로 표현됩니다.
2. **`char *byte_ptr = (char *)&num;`**:
    - `&num`은 `int` 변수 `num`의 메모리 주소를 얻어옵니다. 이 주소의 타입은 `int*`입니다.
    - `(char *)`는 이 `int*` 타입의 주소를 `char*` 타입으로 **타입 캐스팅(강제 형변환)**합니다. 이제 `byte_ptr`은 `num`이 저장된 메모리 공간의 시작 주소를 1바이트 단위로 가리킬 수 있게 됩니다.
3. **`for (size_t i = 0; i < sizeof(int); i++)`**:
    - `sizeof(int)`는 `int` 타입이 차지하는 바이트 수를 알려줍니다 (대부분 4).
    - 루프는 0부터 `sizeof(int) - 1`까지 반복하며 각 바이트에 접근합니다.
4. **`byte_ptr[i]`**:
    - 이것은 포인터 `byte_ptr`을 마치 배열처럼 사용하여 `i`번째 바이트의 값을 직접 읽어오는 것입니다.
    - 리틀 엔디안 시스템에서는 `0xFFFFFFFB`에서 최하위 바이트인 `0xFB`가 가장 낮은 주소(0번 인덱스)에 저장되고, 그 다음 `0xFF`, `0xFF`, `0xFF` 순으로 저장됩니다.
5. **`(unsigned char)byte_ptr[i]`**:
    - `char` 타입은 시스템에 따라 `signed char`일 수도 있고 `unsigned char`일 수도 있습니다. 만약 `signed char`이고 값이 음수라면, `printf`가 이를 음수로 해석하여 출력할 수 있습니다.
    - `0xFB` (16진수)는 10진수로 251입니다. 하지만 `signed char`의 범위에서 `251`은 표현되지 못하고 `-5` (또는 다른 음수)로 해석될 수 있습니다.
    - 이를 방지하고 실제 바이트 값을 0-255 범위의 양수로 보려면 `(unsigned char)`로 명시적 캐스팅을 해주는 것이 좋습니다. 이렇게 해야 `0xFB`가 10진수 `251`로, `0xFF`가 `255`로 올바르게 출력됩니다.


----
