
# 2. 정렬

## 2.4 우선순위 큐(Priority Queue)

- 많은 애플리케이션에서는 키(key)를 가진 항목들을 순서대로 처리해야 하지만, 반드시 전체가 완전히 정렬된 순서일 필요는 없으며 한 번에 모두 처리할 필요도 없습니다. 
- 종종 우리는 항목들의 집합을 모은 다음 가장 큰 키를 가진 항목을 처리하고, 그 후에 더 많은 항목을 모아 현재 가장 큰 키를 가진 항목을 처리하는 과정을 반복합니다.
	- 예를 들어, 여러분은 여러 애플리케이션을 동시에 실행할 수 있는 컴퓨터(또는 휴대폰)를 가지고 있을 것입니다.
	- 이러한 효과는 일반적으로 애플리케이션과 관련된 이벤트에 **우선순위(priority)** 를 할당한 다음, 항상 가장 높은 우선순위의 이벤트를 다음에 처리하도록 선택함으로써 달성됩니다. 
	- 대부분의 휴대폰은 **게임 애플리케이션**보다 **수신 전화**에 더 높은 우선순위를 부여하여 처리합니다.

- 이러한 환경에 적합한 자료형은 **'최댓값 제거(remove the maximum)'** 와 **'삽입(insert)'** 이라는 두 가지 연산을 지원합니다. 
- 이러한 자료형을 **우선순위 큐(priority queue)** 라고 합니다. 
- 우선순위 큐를 사용하는 것은 큐(가장 오래된 것을 제거)나 스택(가장 새로운 것을 제거)을 사용하는 것과 유사하지만, 효율적으로 구현하는 것은 더 어렵습니다.

#### 이진 힙 기반 구현

- 이 섹션에서는 두 연산 중 하나 또는 둘 모두가 선형 시간이 걸리는 기본적인 표현 방식에 대해 간단히 논의한 후, **이진 힙(binary heap)** 자료 구조에 기반한 고전적인 우선순위 큐 구현을 살펴봅니다. 
- 이진 힙에서는 특정 순서 제약 조건에 따라 항목들이 배열에 저장되어 '최댓값 제거'와 '삽입' 연산을 효율적으로(**로그 시간(logN)**) 구현할 수 있습니다.

#### 우선순위 큐의 응용

- 우선순위 큐의 중요한 응용 분야는 다음과 같습니다.
	- **시뮬레이션 시스템**: 키가 이벤트 시간에 해당하며, 시간 순서대로 처리됩니다.
	- **작업 스케줄링**: 키가 우선순위에 해당하며, 어떤 작업을 먼저 수행할지를 나타냅니다.
	- **수치 계산**: 키가 계산 오차를 나타내며, 어떤 순서로 오차를 처리해야 할지를 알려줍니다.


#### API
![[Pasted image 20250816201718.png]]


#### 우선순위 큐 클라이언트

- 우선순위 큐 추상화의 가치를 이해하기 위해 다음 문제를 생각해 봅시다: 
	- **N개의 문자열과 그에 연관된 정수 값으로 이루어진 거대한 입력 스트림이 있고, 당신의 목표는 이 입력 스트림에서 가장 크거나 가장 작은 M개의 정수(와 연관된 문자열)를 찾는 것입니다.**
	- 이 스트림은 큰 거래를 찾아야 하는 금융 거래일 수도 있고, 작은 값을 찾아야 하는 농산물의 살충제 수치일 수도 있으며, 서비스 요청 결과, 과학 실험 결과 등 무엇이든 될 수 있습니다.
- 일부 애플리케이션에서는 입력 스트림의 크기가 너무 커서 제한이 없는(unbounded) 것으로 간주하는 것이 최선입니다. 
	- 이 문제를 해결하는 한 가지 방법은 입력 스트림을 정렬한 다음 가장 큰 M개의 키를 가져오는 것이지만, 우리는 방금 입력 스트림이 너무 커서 그럴 수 없다고 규정했습니다. 
	- 또 다른 접근법은 각각의 새로운 키를 지금까지 찾은 가장 큰 M개의 키와 비교하는 것이지만, 이 방법 또한 M이 작지 않다면 엄청난 비용이 들 가능성이 높습니다.
- 우선순위 큐를 사용하면, `insert()`와 `delMin()` 양쪽 모두에 대한 효율적인 구현을 제공할 수 있다는 **전제하에**, 다음 페이지의 `MinPQ` 클라이언트 `TopM`을 이용해 이 문제를 해결할 수 있습니다.
- 이것이 바로 이 섹션에서의 우리의 목표입니다. 현대의 컴퓨팅 인프라에서 마주칠 가능성이 있는 거대한 N 값에 대해, 이러한 구현은 문제를 해결할 수 있는지 아니면 자원이 부족하여 전혀 해결할 수 없는지의 차이를 만들 수 있습니다.

![[Pasted image 20250816201933.png]]

-----

### 기본적인 구현 방법

- 앞서 논의했던 기본적인 자료 구조들은 우선순위 큐를 구현하기 위한 네 가지 즉각적인 출발점을 제공합니다. 
	- 정렬된 상태 또는 정렬되지 않은 상태로 유지되는 **배열**이나 **연결 리스트**를 사용할 수 있습니다. 
- 이러한 구현 방법들은 작은 우선순위 큐나, 두 연산 중 하나의 사용이 지배적인 경우, 또는 연산에 포함된 키의 순서에 대해 어떤 가정을 할 수 있는 상황에서 유용합니다.

#### 배열 표현 (정렬되지 않은)
- 아마도 가장 간단한 우선순위 큐 구현은 2.1절의 푸시다운 스택(pushdown stack)을 위한 코드를 기반으로 하는 것입니다. 
- 우선순위 큐에서의 **삽입(insert)** 코드는 스택에서의 **푸시(push)** 와 동일합니다.
- **최댓값 제거(remove the maximum)** 를 구현하기 위해, 선택 정렬(selection sort)의 내부 루프와 같은 코드를 추가하여 최댓값 항목을 마지막 항목과 교환한 다음, 스택에서 `pop()`으로 했던 것처럼 그 항목을 삭제할 수 있습니다. 
- 스택에서와 마찬가지로, 자료 구조가 항상 최소 4분의 1 이상 채워져 있고 오버플로우가 발생하지 않도록 크기 조절 배열(resizing-array) 코드를 추가할 수 있습니다.

#### 배열 표현 (정렬된)
- 또 다른 접근법은 **삽입(insert)** 시 더 큰 항목들을 한 칸씩 뒤로 이동시켜, 배열 내의 키들이 (삽입 정렬처럼) 순서를 유지하도록 코드를 추가하는 것입니다. 
- 이렇게 하면 가장 큰 요소는 항상 배열의 끝에 위치하게 되므로, 우선순위 큐에서 **최댓값을 제거(remove the maximum)** 하는 코드는 스택에서의 **pop**과 동일해집니다.

#### 연결 리스트 표현
- 마찬가지로, 우리는 푸시다운 스택을 위한 연결 리스트 코드로 시작할 수 있습니다.
- `pop()` 코드를 수정하여 최댓값을 찾아 반환하거나, 또는 `push()` 코드를 수정하여 키를 _역순으로_ 유지하고 리스트의 첫 번째(최댓값) 항목의 연결을 끊고 반환하도록 할 수 있습니다.

![[Pasted image 20250816202730.png]]

----
- 정렬되지 않은 시퀀스를 사용하는 것은 이 문제에 대한 전형적인 **느긋한 접근 방식(lazy approach)** 으로, 필요한 시점까지 작업(최댓값 찾기)을 미루는 것입니다. 
- 반면, 정렬된 시퀀스를 사용하는 것은 전형적인 **적극적인 접근 방식(eager approach)** 으로, 나중의 연산을 효율적으로 만들기 위해 가능한 한 많은 작업을 미리 수행하는(리스트를 미리 정렬된 상태로 유지하는) 것입니다.

- 스택이나 큐를 구현하는 것과 우선순위 큐를 구현하는 것의 중요한 차이점은 성능과 관련이 있습니다.
- 스택과 큐의 경우, 모든 연산이 **상수 시간(constant time)** 에 수행되는 구현을 개발할 수 있었습니다.
- 하지만 우선순위 큐의 경우, 우리가 방금 논의한 모든 기본적인 구현들은 `삽입` 또는 `최댓값 제거` 연산 중 하나가 최악의 경우 **선형 시간(linear time)** 이 걸린다는 특성을 가집니다. 
- 우리가 다음에 살펴볼 **힙(heap)** 자료 구조는 _두 연산 모두_ 빠르다고 보장되는 구현을 가능하게 합니다.
![[Pasted image 20250816202544.png]]


#### 힙(Heap)의 정의

- **이진 힙(binary heap)** 은 우선순위 큐의 기본 연산들을 효율적으로 지원할 수 있는 자료 구조입니다. 
- 이진 힙에서는 키(key)들이 배열에 저장되며, 각 키는 두 개의 다른 특정 위치에 있는 키들보다 크거나 같음(larger than or equal to)이 보장됩니다. 
- 그리고 그 키들 또한 각각 다른 두 개의 키들보다 크거나 같음이 보장되는 식이 계속됩니다. 
- 이러한 순서 관계는, 각 키와 그보다 작다고 알려진 두 키 사이에 간선(edge)이 있는 이진 트리 구조로 보면 쉽게 이해할 수 있습니다.

> **정의.** 어떤 이진 트리의 각 노드에 있는 키가 자신의 두 자식 노드(있는 경우)의 키들보다 크거나 같을 때, 그 트리는 **힙으로 정렬되었다(heap-ordered)**고 합니다.

- 이는 힙으로 정렬된 이진 트리의 각 노드에 있는 키가 자신의 부모 노드(있는 경우)의 키보다 작거나 같다는 말과 같습니다. 
- 어떤 노드에서든 위로 올라가면 키의 비감소(nondecreasing) 시퀀스를 얻게 되고, 아래로 내려가면 비증가(nonincreasing) 시퀀스를 얻게 됩니다. 특히 다음이 성립합니다.

> **명제 O.** 힙으로 정렬된 이진 트리에서 가장 큰 키는 루트(root)에 있습니다.
> **증명.** 트리의 크기에 대한 귀납법으로 증명할 수 있습니다.


#### 이진 힙 표현

- 만약 힙으로 정렬된 이진 트리를 연결 리스트 표현법으로 구현한다면, 트리를 위아래로 탐색할 수 있도록 각 키마다 세 개의 링크(부모 노드를 가리키는 포인터 하나와 각 자식 노드를 가리키는 포인터 하나씩)가 필요할 것입니다.
- 대신 다음에 그려진 것과 같은 **완전(complete) 이진 트리**를 사용하는 것이 특히 편리합니다. 
- 이러한 구조는 루트 노드를 맨 위에 배치한 다음, 이전 레벨의 각 노드 아래에 N개의 노드를 모두 그릴 때까지 페이지를 아래로 그리고 왼쪽에서 오른쪽으로 진행하며 그립니다. 
- 완전 트리는 명시적인 포인터를 사용하지 않는 간결한 배열 표현을 사용할 기회를 제공합니다. 
	- 구체적으로, 우리는 노드들을 **레벨 순서(level order)** 로 배열에 순차적으로 넣어 완전 이진 트리를 표현합니다. 
	- 루트는 위치 1에, 그 자식들은 위치 2와 3에, 그들의 자식들은 위치 4, 5, 6, 7에 위치시키는 방식입니다.

![[Pasted image 20250816203412.png]]

----

> **정의.** **이진 힙(binary heap)** 은 **힙으로 정렬된 완전 이진 트리(complete heap-ordered binary tree)** 형태로 배열된 키(key)들의 집합으로, 배열에 **레벨 순서(level order)** 로 표현됩니다(배열의 첫 번째 항목은 사용하지 않음).

- **(간결함을 위해, 지금부터는 "이진"이라는 수식어를 생략하고 이진 힙을 지칭할 때 힙이라는 용어를 사용하겠습니다.)** 
- 힙에서 위치 `k`에 있는 노드의 부모는 위치 `⌊k/2⌋`에 있고, 반대로 위치 `k`에 있는 노드의 두 자식은 위치 `2k`와 `2k + 1`에 있습니다. 
- 명시적인 링크(포인터)를 사용하는 대신, 우리는 간단한 배열 인덱스 연산을 통해 트리에서 위아래로 이동할 수 있습니다. 
	- 즉, `a[k]`에서 트리 위로 **올라가려면(move up)** `k`를 `k/2`로 설정하고, 트리 아래로 **내려가려면(move down)** `k`를 `2*k` 또는 `2*k+1`로 설정합니다.

- 배열로 표현된 완전 이진 트리(힙)는 경직된 구조이지만, 효율적인 우선순위 큐 연산을 구현할 수 있을 만큼의 유연성은 갖추고 있습니다. 
- 구체적으로, 우리는 이 구조를 사용하여 **로그 시간(logN)** 이 걸리는 `삽입(insert)` 및 `최댓값 제거(remove the maximum)` 구현을 개발할 것입니다. 
- 이러한 알고리즘들은 포인터 없이 트리의 경로를 따라 위아래로 이동하는 이점을 활용하며, 완전 이진 트리의 다음 속성 덕분에 로그 성능이 보장됩니다.

> **명제 P.** 크기가 N인 완전 이진 트리의 높이는 `⌊lg N⌋` 입니다.
> **증명.** 명시된 결과는 귀납법을 사용하거나, N이 2의 거듭제곱일 때 높이가 1씩 증가한다는 점을 이용하여 쉽게 증명할 수 있습니다.


----
### 힙에서의 알고리즘

- 우리는 크기 `N`인 힙을 길이 `N + 1`의 배열 `pq[]`에 표현합니다.
- `pq[0]`은 사용하지 않으며, 힙의 항목들은 `pq[1]`부터 `pq[N]`까지에 저장됩니다. 
- 정렬 알고리즘과 마찬가지로, 모든 인스턴스 변수가 비공개(private)이므로 키에 대한 접근은 도우미 함수인 `less()`와 `exch()`를 통해서만 이루어집니다.

- 다음에서 다룰, 배열 이름을 매개변수로 받지 않는 더 간결한 구현을 위해, 우리가 고려할 힙 연산들은 먼저 힙 조건을 위반할 수 있는 간단한 수정을 한 다음, 힙을 따라 이동하며 힙 조건이 모든 곳에서 만족되도록 수정하는 방식으로 작동합니다. 
- 이 과정을 **힙 재구성(reheapifying)** 또는 **힙 순서 복원(restoring heap order)**이라고 합니다.

- 두 가지 경우가 있습니다. 
	- 노드의 우선순위가 증가하면(또는 새 노드가 힙의 맨 아래에 추가되면), 힙 순서를 복원하기 위해 힙을 **위로(up)** 이동해야 합니다. 
	- 노드의 우선순위가 감소하면(예를 들어, 루트에 있는 노드를 더 작은 키를 가진 새 노드로 교체하는 경우), 힙 순서를 복원하기 위해 힙을 **아래로(down)** 이동해야 합니다. 
- 먼저 이 두 가지 기본 보조 연산을 구현하는 방법을 고려한 다음, 이들을 사용하여 `삽입(insert)`과 `최댓값 제거(remove the maximum)`를 구현하는 방법을 살펴보겠습니다.

----

#### 상향식 힙 재구성 (헤엄쳐 올라가기, swim)

- 힙 순서는 노드의 키가 부모 노드의 키보다 **커져서** 위반될 수 있습니다. 
- 이 경우, 해당 노드를 부모와 교환함으로써 위반을 수정하는 방향으로 나아갈 수 있습니다. 
- 교환 후, 그 노드는 자신의 두 자식보다 커집니다(하나는 이전 부모였고, 다른 하나는 그 이전 부모의 자식이었으므로 더 작습니다). 
- 하지만 그 노드는 여전히 자신의 _새로운_ 부모보다 클 수 있습니다. 
- 따라서 더 큰 키를 가진 부모 노드에 도달하거나 루트에 도달할 때까지 힙을 위로 올라가며 이 과정을 반복할 수 있습니다. 
- 힙에서 위치 `k`에 있는 노드의 부모가 위치 `k/2`에 있다는 것을 명심하면 이 과정을 코딩하는 것은 간단합니다. 루프는 오직 한 곳에서만 힙 순서가 위반된다는 불변성(invariant)을 유지합니다.

- 힙 순서는 위치 `k`에 있는 노드가 자신의 부모보다 커질 때 위반될 수 있습니다. 
- 따라서 노드가 자신의 부모보다 크지 않은 위치, 즉 힙 순서가 트리를 통틀어 만족되는 곳에 도달하면 멈춥니다. 
- 메서드의 이름을 정당화하기 위해, 새로운 노드가 너무 큰 키를 가져서 힙의 더 높은 레벨로 **헤엄쳐 올라가야(swim)** 한다고 생각합니다.

![[Pasted image 20250816203953.png]]

#### 하향식 힙 재구성 (가라앉기, sink)

- 힙 순서가 노드의 키가 자신의 자식 노드 중 하나 또는 둘 모두보다 **작아져서** 위반되는 경우, 해당 노드를 두 자식 중 **더 큰** 쪽과 교환함으로써 위반을 수정하는 방향으로 나아갈 수 있습니다.
- 이 교환은 자식 노드에서 또 다른 위반을 야기할 수 있으므로, 두 자식 노드보다 크거나 같은(또는 바닥에 도달한) 노드에 도달할 때까지 힙을 아래로 내려가며 같은 방식으로 위반을 수정합니다. 
- 아래 코드는 위치 `k`에 있는 노드의 자식들이 배열의 `2k`와 `2k+1` 위치에 있다는 사실로부터 직접적으로 나옵니다. 
- 메서드의 이름을 정당화하기 위해, 새로운 노드가 너무 작은 키를 가져서 힙의 더 낮은 레벨로 **가라앉아야(sink)** 한다고 생각합니다.

![[Pasted image 20250816204159.png]]

----

- 이 `sink()`와 `swim()` 연산들은 아래에 도식화되고 다음에 구현된 것처럼, 우선순위 큐 API의 효율적인 구현을 위한 기초를 제공합니다.
##### 삽입 (Insert)
- 새로운 키를 배열의 끝에 추가하고, 힙의 크기를 1 증가시킨 다음, 그 키를 가지고 힙을 위로 올라가며(swim) 힙 조건을 복원합니다.
##### 최댓값 제거 (Remove the maximum)
- 가장 큰 키를 맨 위에서 가져오고, 힙의 끝에 있던 항목을 맨 위로 가져온 다음, 힙의 크기를 1 감소시키고, 그 키를 가지고 힙을 아래로 내려가며(sink) 힙 조건을 복원합니다.
- 
![[Pasted image 20250816204354.png]]
---

- 다음 구현은 이 절의 시작 부분에서 제기했던 기본 문제를 해결합니다. 
- 이것은 `삽입(insert)`과 `최댓값 제거(delete the maximum)` 연산 모두 큐의 크기에 대해 **로그 시간(logarithmic time)** 이 걸리는 것이 보장되는 우선순위 큐 API 구현입니다.

```C++

template <typename Key>
class MaxPQ {
public:
	// 생성자: 최대 용량을 받아 우선순위 큐를 생성합니다.
	explicit MaxPQ(int max_capacity) : capacity(max_capacity), num_elements(0) {
		// 힙 구현의 편의를 위해 1-based indexing을 사용하므로,
		// 배열 크기를 capacity + 1로 할당합니다.
		priority_queue = new Key[max_capacity + 1];
	}

	// 소멸자: 동적으로 할당된 메모리를 해제합니다.
	~MaxPQ() {
		delete[] priority_queue;
	}

	// 우선순위 큐에 새로운 원소를 추가합니다.
	void insert(const Key& value) {
		if (num_elements >= capacity) {
			throw std::overflow_error("Priority queue is full");
		}
		// 1. 가장 마지막 위치에 원소를 추가합니다.
		priority_queue[++num_elements] = value;
		// 2. 힙 속성을 복원하기 위해 부모 노드와 비교하며 위로 올라갑니다.
		swim(num_elements);
	}

	// 가장 큰 원소(루트)를 제거하고 반환합니다.
	Key del_max() {
		if (is_empty()) {
			throw std::out_of_range("Priority queue is empty");
		}
		// 1. 루트 노드(최댓값)를 저장합니다.
		Key max_value = priority_queue[1];
		// 2. 가장 마지막 노드를 루트로 이동시킵니다.
		swap_elements(1, num_elements--);
		// 3. 힙 속성을 복원하기 위해 자식 노드와 비교하며 아래로 내려갑니다.
		sink(1);
		return max_value;
	}

	// 우선순위 큐가 비어있는지 확인합니다.
	bool is_empty() const {
		return num_elements == 0;
	}

	// 우선순위 큐에 포함된 원소의 개수를 반환합니다.
	int size() const {
		return num_elements;
	}

private:
	// 두 원소의 우선순위를 비교합니다. (i < j)
	bool less(int i, int j) const {
		return priority_queue[i] < priority_queue[j];
	}

	// 두 원소의 위치를 교환합니다.
	void swap_elements(int i, int j) {
		std::swap(priority_queue[i], priority_queue[j]);
	}

	// swim: 자식 노드가 부모 노드보다 클 경우, 위로 올라가며 힙을 재구성합니다.
	void swim(int k) {
		while (k > 1 && less(k / 2, k)) {
			swap_elements(k / 2, k);
			k = k / 2;
		}
	}

	// sink: 부모 노드가 자식 노드보다 작을 경우, 아래로 내려가며 힙을 재구성합니다.
	void sink(int k) {
		while (2 * k <= num_elements) {
			int child = 2 * k;
			// 두 자식 중 더 큰 자식을 선택합니다.
			if (child < num_elements && less(child, child + 1)) {
				child++;
			}
			// 부모가 자식보다 크거나 같으면 힙 속성이 만족된 상태입니다.
			if (!less(k, child)) {
				break;
			}
			// 부모와 자식의 위치를 바꾸고 계속 아래로 내려갑니다.
			swap_elements(k, child);
			k = child;
		}
	}

	Key* priority_queue; // 힙을 저장할 배열 포인터
	int capacity;        // 최대 용량
	int num_elements;    // 현재 원소 개수
};
```

![[Pasted image 20250816205436.png]]

> **명제 Q.** N개의 키를 가진 우선순위 큐에서, 힙 알고리즘은 **삽입** 연산에 대해 1+lgN회 이하의 비교를, **최댓값 제거** 연산에 대해 2lgN회 이하의 비교를 필요로 합니다.
> **증명:** 명제 P에 의해, 두 연산 모두 힙의 루트와 마지막 레벨 사이의 경로를 따라 이동하는 과정을 포함하며, 이 경로의 링크 수는 lgN을 넘지 않습니다. 최댓값 제거 연산은 경로상의 각 노드(마지막 레벨 제외)에 대해 두 번의 비교를 필요로 합니다. 하나는 더 큰 키를 가진 자식을 찾는 것이고, 다른 하나는 그 자식이 위로 올라가야 하는지를 결정하는 것입니다.

- 큰 우선순위 큐에서 수많은 삽입 및 최댓값 제거 연산이 혼합되어 사용되는 일반적인 응용 프로그램의 경우, **명제 Q**는 312페이지의 표에 요약된 바와 같이 중요한 성능의 획기적인 발전을 의미합니다. 
- 정렬된 배열이나 정렬되지 않은 배열을 사용하는 기초적인 구현 방식에서는 두 연산 중 하나가 **선형 시간**을 필요로 하는 반면, 힙 기반 구현은 두 연산 모두 **로그 시간** 내에 완료됨을 보장합니다. 이러한 개선은 어떤 문제를 해결할 수 있느냐 없느냐의 차이를 만들 수 있습니다.

----
##### 다중 힙 (Multiway heaps)
- 우리의 코드를 수정하여 완전 힙 순서의 **3진 트리**를 배열로 표현하는 힙을 만드는 것은 어렵지 않습니다. 
- 이 경우 N개 항목의 배열에서 1과 N 사이의 모든 인덱스 k에 대해, k 위치의 항목은 3k−1,3k,3k+1 위치의 항목보다 크거나 같고, ⌊(k+1)/3⌋ 위치의 항목보다 작거나 같습니다. 
	- 또한 주어진 d에 대해 **_d_진 힙**을 사용하는 것도 그리 어렵지 않습니다.
- 여기에는 감소된 트리의 높이(logd​N)로 인한 비용 감소와, 각 노드에서 d개의 자식 중 가장 큰 자식을 찾는 데 드는 비용 증가 사이에 **상충 관계(tradeoff)** 가 존재합니다. 
- 이 상충 관계는 구현의 세부 사항과 연산들의 예상 상대 빈도에 따라 달라집니다.

##### 배열 크기 조절 (Array resizing)
- 1.3절에서 스택에 대해 했던 것처럼, 인자 없는 생성자를 추가하고, `insert()`에서 배열 크기를 두 배로 늘리고 `delMax()`에서 배열 크기를 절반으로 줄이는 코드를 추가할 수 있습니다. 
- 이렇게 하면 클라이언트는 임의의 크기 제한에 대해 걱정할 필요가 없습니다. 
- 명제 Q가 보장하는 로그 시간 복잡도는 우선순위 큐의 크기가 임의적이고 배열 크기가 조절될 때 **분할 상환(amortized)** 분석에 따른 것입니다.

##### 키의 불변성 (Immutability of keys)
- 우선순위 큐는 클라이언트에 의해 생성된 객체를 다루지만, 클라이언트 코드가 키를 변경하지 않는다고 가정합니다 (키를 변경하면 **힙 순서 불변식**이 깨질 수 있습니다). 
- 이러한 가정을 강제하는 메커니즘을 개발하는 것도 가능하지만, 프로그래머들은 일반적으로 그렇게 하지 않습니다. 
- 왜냐하면 코드가 복잡해지고 성능을 저하시킬 가능성이 있기 때문입니다.

##### 인덱스 우선순위 큐 (Index priority queue)
- 많은 응용 프로그램에서, 클라이언트가 이미 우선순위 큐에 있는 항목을 참조할 수 있도록 하는 것이 유용합니다. 
- 이를 위한 한 가지 쉬운 방법은 각 항목에 고유한 정수 **인덱스**를 연관시키는 것입니다. 
- 더 나아가, 클라이언트가 이미 알고 있는 크기 _N_의 전체 항목 집합을 가지고 있고, 항목에 대한 정보를 저장하기 위해 (병렬적인) 배열을 사용하고 있을 수 있습니다. 
- 따라서 다른 관련 없는 클라이언트 코드가 이미 정수 인덱스를 사용하여 항목을 참조하고 있을 수도 있습니다. 
- 이러한 고려 사항들은 다음 API로 이어집니다:

![[Pasted image 20250816205957.png]]


- 이 자료형을 생각하는 유용한 방법은 배열을 구현하되, 배열 내의 가장 작은 항목에 빠르게 접근할 수 있는 것으로 보는 것입니다. 
- 사실 이것은 그보다 더 좋습니다. 
	- 배열 항목들의 **지정된 부분집합**(삽입된 항목들) 내에서 최솟값에 빠르게 접근할 수 있게 해줍니다. 
- 다시 말해, `pq`라는 이름의 `IndexMinPQ`를 항목 배열 `pq[0..N-1]`의 부분집합을 나타내는 것으로 생각할 수 있습니다.
- `pq.insert(k, item)` 호출은 인덱스 k를 부분집합에 추가하고 `pq[k] = item`으로 설정하는 것으로, `pq.change(k, item)` 호출은 `pq[k] = item`으로 설정하는 것으로 생각할 수 있습니다. 
- 두 호출 모두 다른 연산들, 특히 `delMin()`(최소 키의 인덱스를 제거하고 반환)과 `change()`(이미 자료구조에 있는 인덱스와 연관된 항목을 변경—`pq[i] = item`처럼)를 지원하는 데 필요한 자료구조를 유지합니다. 
- 이러한 연산들은 많은 응용 프로그램에서 중요하며, (인덱스를 통해) 키를 참조하는 우리의 능력 덕분에 가능해집니다. 
- 직관적으로, 힙의 항목이 변경될 때, 우리는 **sink** 연산(키가 증가하는 경우)과 **swim** 연산(키가 감소하는 경우)으로 **힙 불변식**을 복원할 수 있습니다. 
- 이러한 연산을 수행하기 위해, 우리는 인덱스를 사용하여 힙에서 해당 항목을 찾습니다. 힙에서 항목의 위치를 찾는 이 능력은 API에 `delete()` 연산을 추가하는 것도 가능하게 합니다.


---

### 힙 정렬 (Heapsort)

- 어떤 우선순위 큐든 정렬 방법을 개발하는 데 사용할 수 있습니다. 
- 정렬할 모든 항목을 최소 지향 우선순위 큐에 삽입한 다음, **최솟값 제거**를 반복적으로 사용하여 모든 항목을 순서대로 제거합니다. 
- 이런 방식으로 정렬되지 않은 배열로 표현된 우선순위 큐를 사용하는 것은 **선택 정렬**을 하는 것과 같고, 정렬된 배열을 사용하는 것은 **삽입 정렬**을 하는 것과 같습니다. 
- 그렇다면 힙을 사용하면 어떤 정렬 방법을 얻게 될까요? 
	- 완전히 다른 것입니다! 이제 우리는 힙을 사용하여 **힙 정렬(heapsort)** 로 알려진 고전적이고 우아한 정렬 알고리즘을 개발할 것입니다.

- 힙 정렬은 두 단계로 나뉩니다.
	1. **힙 구성 (heap construction)**: 원본 배열을 힙으로 재구성하는 단계
	2. **정렬 제거 (sortdown)**: 힙에서 항목들을 감소 순서로 꺼내 정렬된 결과를 만드는 단계

- 우리가 학습한 코드와의 일관성을 위해, 최대 지향 우선순위 큐를 사용하고 최댓값을 반복적으로 제거할 것입니다. 
- 정렬 작업에 집중하기 위해, 우선순위 큐의 표현을 숨기는 개념을 버리고 `swim()`과 `sink()`를 직접 사용합니다. 
- 이렇게 함으로써 정렬할 배열 내에서 힙을 유지하여 **추가 공간 없이** 배열을 정렬할 수 있습니다.

----
#### 힙 구성 (Heap construction)

- 주어진 N개의 항목으로 힙을 만드는 과정은 얼마나 어려울까요? 
- 배열을 왼쪽에서 오른쪽으로 진행하면서, 스캔 포인터의 왼쪽에 있는 항목들이 힙 순서의 완전 트리를 이루도록 `swim()`을 사용하면, 연속적인 우선순위 큐 삽입처럼 NlogN에 비례하는 시간 안에 이 작업을 확실히 완수할 수 있습니다.

- 훨씬 더 효율적인 영리한 방법은 **오른쪽에서 왼쪽으로** 진행하며, 진행하면서 `sink()`를 사용하여 서브 힙을 만드는 것입니다. 
- 배열의 모든 위치는 작은 서브 힙의 루트입니다. 
	- `sink()`는 그러한 서브 힙에 대해서도 잘 작동합니다. 
- 어떤 노드의 두 자식이 힙이라면, 그 노드에 대해 `sink()`를 호출하면 부모를 루트로 하는 서브 트리가 힙이 됩니다. 
	- 이 과정은 귀납적으로 힙 순서를 설정합니다. 
	- 스캔은 배열의 중간 지점에서 시작하는데, 크기가 1인 서브 힙은 건너뛸 수 있기 때문입니다. 
	- 스캔은 1번 위치에서 끝나며, 이때 한 번의 `sink()` 호출로 힙 구성을 마칩니다. 
- 정렬의 첫 번째 단계로서, 힙 구성은 약간 직관에 반합니다. 
	- 왜냐하면 그 목표는 힙 순서의 결과를 만드는 것인데, 이것은 가장 큰 항목이 배열의 맨 앞에 (그리고 다른 큰 항목들이 시작 부분 근처에) 위치하게 되기 때문입니다. 
	- 최종적으로 위치해야 할 끝이 아니라요.

> **명제 R.** `sink` 기반의 힙 구성은 N개의 항목으로 힙을 구성하는 데 **2N회 미만의 비교**와 **N회 미만의 교환**을 사용합니다.
> **증명:** 이 사실은 처리되는 대부분의 힙이 작다는 관찰에서 비롯됩니다. 예를 들어, 127개 요소의 힙을 만들려면, 크기 3의 힙 32개, 크기 7의 힙 16개, 크기 15의 힙 8개, 크기 31의 힙 4개, 크기 63의 힙 2개, 크기 127의 힙 1개를 처리하므로, 32⋅1+16⋅2+8⋅3+4⋅4+2⋅5+1⋅6=120회의 교환(비교는 두 배)이 (최악의 경우) 필요합니다. 

#### 정렬 제거 (Sortdown)

- 힙 정렬의 대부분 작업은 두 번째 단계에서 이루어집니다. 
- 이 단계에서는 힙에서 남아있는 가장 큰 항목을 제거하고 힙이 줄어들면서 비워진 배열 위치에 놓습니다. 
- 이 과정은 항목을 오름차순 대신 내림차순으로 가져온다는 점만 제외하면 **선택 정렬**과 약간 비슷하지만, 힙이 배열의 정렬되지 않은 부분에서 가장 큰 항목을 찾는 훨씬 효율적인 방법을 제공하기 때문에 비교 횟수가 훨씬 적습니다.

>**명제 S.** 힙 정렬은 N개의 항목을 정렬하는 데 **2NlgN+2N회 미만의 비교**(그리고 그 절반 횟수의 교환)를 사용합니다.
>**증명:** 2N 항은 힙 구성 비용을 포함합니. 2NlgN 항은 정렬 제거 단계 동안 각 sink 연산의 비용을 2lgN으로 제한함으로써 도출됩니다.


```cpp
template <typename T>
class HeapSort : public Sort<T>
{
public:
    // 힙 정렬을 수행하는 메인 함수
    void sort(T arr[], int n) override {
        // 1. 힙 구성(Heap Construction) 단계
        // 배열의 중간(마지막 부모 노드)부터 시작하여 루트까지 sink를 호출하여
        // 배열 전체를 최대 힙(max-heap) 상태로 만듭니다.
        for (int k = n / 2 - 1; k >= 0; k--) {
            sink(arr, k, n);
        }

        // 2. 정렬 제거(Sortdown) 단계
        // 힙의 크기를 1씩 줄여나가면서 정렬을 완성합니다.
        for (int i = n - 1; i > 0; i--) {
            // 현재 힙의 최대값(arr[0])을 힙의 마지막 원소와 교환합니다.
            this->swap(arr, 0, i);
            
            // 힙의 크기를 줄이고(i), 루트(0)에서 sink를 호출하여
            // 힙 속성을 복원합니다.
            sink(arr, 0, i);
        }
    }

private:
    // 특정 노드(k)를 아래로 내려보내 힙 속성을 만족시키는 함수
    // n은 현재 힙의 크기를 나타냅니다.
    void sink(T arr[], int k, int n) {
        // 자식 노드가 존재하는 동안 반복 (왼쪽 자식 기준)
        while (2 * k + 1 < n) {
            int child = 2 * k + 1; // 왼쪽 자식 인덱스

            // 오른쪽 자식이 존재하고, 왼쪽 자식보다 크다면 오른쪽 자식을 선택
            if (child + 1 < n && arr[child] < arr[child + 1]) {
                child++;
            }

            // 부모(k)가 선택된 자식보다 크거나 같으면 힙 속성이 만족된 상태이므로 종료
            if (!(arr[k] < arr[child])) {
                break;
            }

            // 부모와 자식의 위치를 교환하고, 계속 아래로 내려갑니다.
            this->swap(arr, k, child);
            k = child;
        }
    }
};
```


![[Pasted image 20250816214026.png]]

![[Pasted image 20250816214427.png]]

----

- 힙 정렬 알고리즘은 이러한 아이디어에 기반한 완전한 구현으로, 1964년 J. W. Williams가 발명하고 R. W. Floyd가 개선한 고전적인 **힙 정렬** 알고리즘입니다. 
- 이 프로그램의 루프들은 서로 다른 작업을 수행하는 것처럼 보이지만(첫 번째는 힙을 구성하고, 두 번째는 정렬 제거를 위해 힙을 파괴), 둘 다 `sink()` 메소드를 중심으로 구축됩니다. 
- 우리는 정렬 알고리즘의 단순성(`sort()`를 위한 8줄의 코드와 `sink()`를 위한 또 다른 8줄의 코드)을 강조하고 이를 **제자리 정렬(in-place sort)** 로 만들기 위해 우선순위 큐 API 외부에서 구현을 제공합니다.

- 평소처럼, 시각적 추적을 통해 알고리즘의 작동에 대한 통찰력을 얻을 수 있습니다. 
- 처음에는 힙이 구성되면서 큰 항목들이 배열의 시작 부분으로 이동하기 때문에, 이 과정이 정렬과는 거리가 먼 것처럼 보입니다. 
- 하지만 그 후에는 이 방법이 선택 정렬의 거울 이미지처럼 보입니다(훨씬 적은 비교를 사용한다는 점은 제외하고).
