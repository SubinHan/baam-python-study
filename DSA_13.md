
# 3. 검색

## 3.1 심볼 테이블

- 심볼 테이블의 주된 목적은 **값(value)** 을 **키(key)** 와 연관시키는 것입니다. 
- 클라이언트는 나중에 주어진 키와 연관된 값을 테이블에 저장된 모든 키-값 쌍 중에서 **검색(search)** 할 수 있으리라는 기대를 가지고 심볼 테이블에 키-값 쌍을 **삽입(insert)** 할 수 있습니다. 
- 이 절에서는 _삽입_ 과 _검색_ 연산뿐만 아니라 여러 다른 편리한 연산들도 효율적으로 만들기 위해 이 데이터를 구조화하는 여러 방법을 설명합니다. 
- 심볼 테이블을 구현하기 위해서는, 기반이 되는 자료구조를 정의하고 그 자료구조를 생성하고 조작하는 삽입, 검색 및 기타 연산들을 위한 알고리즘을 명시해야 합니다.

- 검색은 수많은 컴퓨터 애플리케이션에 매우 중요하기 때문에, 심볼 테이블은 많은 프로그래밍 환경에서 고수준 추상화로 제공됩니다. 
- 아래 표는 일반적인 애플리케이션에서 사용할 수 있는 키와 값의 몇 가지 예를 보여줍니다. 
	- 우리는 곧 몇 가지 예시적인 클라이언트 예제를 살펴볼 것이며, 3.5절에서는 여러분 자신의 클라이언트에서 심볼 테이블을 효과적으로 사용하는 방법을 보여주는 데 할애됩니다. 
	- 우리는 또한 책 전반에 걸쳐 다른 알고리즘을 개발하는 데 심볼 테이블을 사용합니다.

> **정의.** **심볼 테이블** 은 두 가지 연산을 지원하는 키-값 쌍을 위한 자료구조입니다: 테이블에 새로운 쌍을 **삽입(insert)** (put) 하고 주어진 **키(key)** 와 연관된 **값(value)** 을 **검색(search)** (get) 하는 것입니다.

![[Pasted image 20250817192928.png]]

### API
- 심볼 테이블은 프로토타입 격인 **추상 데이터 타입(abstract data type)** 입니다.
    - 이것은 잘 정의된 **값(value)** 의 집합과 그 값들에 대한 **연산(operation)** 의 집합을 나타내며, 이를 통해 우리는 클라이언트와 구현을 분리하여 개발할 수 있습니다.
- 늘 그렇듯이, 우리는 클라이언트와 구현 사이의 계약을 제공하는 **응용 프로그래밍 인터페이스(API)** 를 명시함으로써 연산을 정확하게 정의합니다:

![[Pasted image 20250817193533.png]]

- 클라이언트 코드를 살펴보기 전에, 우리는 코드를 일관성 있고, 간결하며, 유용하게 만들기 위해 구현에 대한 몇 가지 설계 선택 사항을 고려합니다.
- **제네릭(Generics).** 정렬에서 했던 것처럼, 우리는 제네릭을 사용하여 처리될 항목의 타입을 지정하지 않고 메서드를 고려할 것입니다. (C++에서는 이것을 **템플릿(template)** 이라고 부릅니다.)
- 심볼 테이블의 경우, 우리는 **키(key)** 와 **값(value)** 타입을 명시적으로 지정함으로써 탐색에서 키와 값이 수행하는 개별적인 역할을 강조합니다.

#### 중복 키
- 저희의 모든 구현에서는 다음 규칙을 채택합니다:
    - 각 **키(key)** 에는 단 **하나의 값(value)** 만 연관됩니다 (테이블 내에 중복된 키는 없습니다).
    - 클라이언트가 테이블에 이미 존재하는 키 (그리고 그에 연관된 값)가 포함된 키-값 쌍을 `put` 하면, **새로운 값이 이전 값을 대체합니다.**
- 이러한 규칙들은 **연관 배열(associative array)** 추상화를 정의합니다.
    - 연관 배열에서 심볼 테이블은 키가 인덱스이고 값이 배열의 항목인, 일반적인 배열과 같다고 생각할 수 있습니다.
- 일반적인 배열에서, 키는 배열 값에 빠르게 접근하기 위해 사용하는 정수 인덱스입니다.
- 연관 배열 (심볼 테이블)에서, 키는 임의의 타입이지만, 우리는 여전히 값에 빠르게 접근하기 위해 키를 사용합니다.
- 일부 프로그래밍 언어 (Java는 아님)는 프로그래머가 `st.get(key)` 대신 `st[key]` 와 같은 코드를, `st.put(key, val)` 대신 `st[key] = val` 과 같은 코드를 사용할 수 있도록 특별한 지원을 제공합니다.
    - C++에서는 연산자 오버로딩을 통해 이 기능을 구현할 수 있습니다.

#### Null 키 (Null keys).
- 키는 `null` 이 될 수 없습니다.
- Java의 많은 메커니즘과 마찬가지로, `null` 키를 사용하면 런타임에 예외가 발생합니다.
#### Null 값 (Null values)
- 우리는 어떤 키도 `null` 값과 연관될 수 없다는 규칙을 채택합니다.
- 이 규칙은 API의 `get()` 메서드가 테이블에 없는 키에 대해 `null` 을 반환해야 한다는 명세와 직접적으로 관련이 있습니다.
- 이 규칙은 두 가지 의도된 결과를 가집니다:
	- `get()` 메서드가 `null` 을 반환하는지 테스트함으로써 주어진 키와 연관된 값이 테이블에 정의되어 있는지 확인할 수 있습니다.
	- `put()` 메서드의 두 번째 인자로 `null` 을 전달하는 호출을 사용하여 삭제를 구현할 수 있습니다.

#### 삭제 (Deletion)

> 심볼 테이블에서의 삭제는 일반적으로 두 가지 전략 중 하나를 포함합니다: **지연 삭제 (lazy deletion)** 는 테이블의 키와 `null` 을 연관시킨 다음 나중에 어떤 시점에 해당 키를 제거하는 것이고, **즉시 삭제 (eager deletion)** 는 테이블에서 키를 즉시 제거하는 것입니다.

- 방금 논의한 것처럼, `put(key, null)` 코드는 `delete(key)` 의 손쉬운 **지연 (lazy)** 구현입니다.
- `delete()` 의 **즉시 (eager)** 구현을 제공할 때, 우리는 이 기본값을 대체하려고 합니다.
- `delete()` 를 사용하지 않는 우리의 심볼 테이블 구현에서, 책에 있는 `put()` 구현은 다음과 같은 방어적인 코드로 시작합니다:
```c++
if (val == nullptr) { 
    delete_key(key); 
    return; 
}
```
- 테이블에 키가 없는 경우 삽입되지 않도록 하기 위함입니다.
- 간결함을 위해, 우리는 이 코드를 책에 포함하지 않습니다 (그리고 클라이언트 코드에서 `null` 값으로 `put()` 을 호출하지 않습니다).

#### 단축 메서드 (Shorthand methods)
- 클라이언트 코드의 명확성을 위해, 우리는 API에 `contains()` 와 `isEmpty()` 메서드를 포함하며, 여기에 표시된 기본 한 줄 구현을 사용합니다.
- 다시 한 번 간결함을 위해, 우리는 이것이 모든 심볼 테이블 API 구현에 존재한다고 가정하고 클라이언트 코드에서 이러한 메서드를 자유롭게 사용합니다.
![[Pasted image 20250817194254.png]]

#### 반복 (Iteration)
- 클라이언트가 테이블의 모든 키와 값을 처리할 수 있도록, API의 첫 줄에 `implements Iterable<Key>` 라는 구문을 추가할 수 있습니다.
    - 이는 모든 구현이 `hasNext()` 와 `next()` 의 적절한 구현을 가진 `Iterator` 를 반환하는 `iterator()` 메서드를 구현해야 함을 명시하기 위함입니다. (스택과 큐에 대해 1.3절에서 설명한 바와 같음)
- 심볼 테이블의 경우, 우리는 더 간단한 대안적 접근 방식을 채택합니다
    - `keys()` 라는 메서드를 명시하여, 클라이언트가 키를 순회하는 데 사용할 `Iterable<Key>` 객체를 반환하도록 합니다.
- 이렇게 하는 이유는, 클라이언트가 테이블에 있는 특정 키의 서브셋을 순회할 수 있도록 하는, 순서 있는 심볼 테이블(ordered symbol tables)을 위해 정의할 메서드와의 일관성을 유지하기 위함입니다.

#### 키 동등성 (Key equality)
- 주어진 키가 심볼 테이블에 있는지 여부를 결정하는 것은 **객체 동등성(object equality)** 이라는 개념에 기반합니다.
- 모든 객체가 `equals()` 메서드를 상속받는다는 Java의 관례와, `Integer` , `Double` , `String` 과 같은 표준 타입 및 `File` , `URL` 과 같은 더 복잡한 타입 모두에 대한 `equals()` 구현은 큰 이점을 줍니다.
    - 이러한 타입의 데이터를 사용할 때, 내장된 구현을 그대로 사용하면 됩니다.
- 예를 들어, `x` 와 `y` 가 `String` 값이라면, `x.equals(y)` 는 `x` 와 `y` 가 동일한 길이를 갖고 각 문자 위치가 동일한 경우에만 `true` 입니다.
- 이러한 클라이언트 정의 키의 경우, 1.2절에서 논의한 바와 같이 `equals()` 를 재정의(override)해야 합니다.
- 여러분은 `Date` 타입에 대한 저희의 `equals()` 구현(103페이지)을 템플릿으로 사용하여 자신만의 타입을 위한 `equals()` 를 개발할 수 있습니다.
- `Key` 타입을 **불변(immutable)** 으로 만드는 것이 가장 좋은 방법입니다.
    - 그렇지 않으면 일관성을 보장할 수 없기 때문입니다.

----

### 정렬된 심볼 테이블(Ordered symbol tables)

- 일반적인 애플리케이션에서, 키는 `Comparable` 객체이므로, `a.compareTo(b)` 코드를 사용하여 두 키 **a** 와 **b** 를 비교하는 옵션이 존재합니다.
- 여러 심볼 테이블 구현은 `Comparable` 에 의해 암시되는 키 간의 순서를 활용하여 `put()` 및 `get()` 연산의 효율적인 구현을 제공합니다.
- 더 중요한 것은, 이러한 구현에서 심볼 테이블을 **키를 순서대로 유지하는 것** 으로 생각할 수 있으며, 상대적인 키 순서와 관련된 수많은 자연스럽고 유용한 연산을 정의하는 상당히 확장된 API를 고려할 수 있습니다.
- 예를 들어, 당신의 키가 하루 중 시간이라고 가정해 봅시다.
    - 당신은 가장 이른 시간이나 가장 늦은 시간, 주어진 두 시간 사이에 있는 키의 집합 등을 알고 싶을 수 있습니다.
- 대부분의 경우, 이러한 연산은 `put()` 및 `get()` 구현의 기반이 되는 동일한 자료구조와 메서드로 구현하기 어렵지 않습니다.
- 특히, 키가 `Comparable` 인 애플리케이션을 위해, 이 장에서는 다음 API를 구현합니다.
- 우리 프로그램 중 하나가 이 API를 구현하고 있다는 신호는 클래스 선언에 `Key extends Comparable<Key>` 제네릭 타입 변수가 있다는 것입니다.
    - 이는 코드가 키가 `Comparable` 이라는 점에 의존하고 더 풍부한 연산 집합을 구현함을 명시합니다.
- 종합적으로, 이러한 연산들은 클라이언트 프로그램을 위해 **정렬된 심볼 테이블** 을 정의합니다.
- 
![[Pasted image 20250824172039.png]]


#### 최소값과 최대값
- 아마도 정렬된 키 집합에 대한 가장 자연스러운 쿼리는 가장 작은 키와 가장 큰 키를 찾는 것입니다.
- 우리는 **SECTION 2.4** 의 우선순위 큐 논의에서 이러한 연산들을 이미 마주한 적이 있습니다.
- 정렬된 심볼 테이블에서도, 우리는 최대값과 최소값 키 (그리고 그와 연관된 값들) 를 삭제하는 메서드를 가지고 있습니다.
- 이 기능을 통해, 심볼 테이블은 **SECTION 2.4** 에서 논의한 `IndexMinPQ()` 클래스처럼 작동할 수 있습니다.
- 주된 차이점은 우선순위 큐에서는 동일한 키가 허용되지만 심볼 테이블에서는 그렇지 않으며, 정렬된 심볼 테이블은 훨씬 더 큰 연산 집합을 지원한다는 것입니다.

#### Floor와 Ceiling
- 주어진 키에 대해, 주어진 키보다 작거나 같은 가장 큰 키를 찾는 `floor` 연산과 주어진 키보다 크거나 같은 가장 작은 키를 찾는 `ceiling` 연산을 수행하는 것이 종종 유용합니다.
- 이 명명법은 실수에 대해 정의된 함수에서 유래했습니다.
    - 실수 x 의 **floor** 는 x 보다 작거나 같은 가장 큰 정수입니다.
    - 실수 x 의 **ceiling** 은 x 보다 크거나 같은 가장 작은 정수입니다.

#### Rank와 Select
- 새로운 키가 순서상 어디에 위치하는지 결정하기 위한 기본 연산은 `rank` 연산 (주어진 키보다 작은 키의 수를 찾는 것) 과 `select` 연산 (주어진 순위의 키를 찾는 것) 입니다.
- 당신의 이해도를 테스트하기 위해, **0** 과 **size() - 1** 사이의 모든 **i** 에 대해 `i == rank(select(i))` 가 성립하고, 테이블의 모든 키에 대해 `key == select(rank(key))` 가 성립함을 스스로 확인해 보십시오.
- 우리는 **SECTION 2.5** 에서 정렬 애플리케이션에 대한 논의에서 이러한 연산들의 필요성을 이미 마주했습니다.
- 심볼 테이블의 경우, 이러한 연산들은 삽입, 삭제, 검색과 빠르게 혼합되어 수행되어야 합니다.

#### 범위 쿼리
- 주어진 범위 (두 개의 주어진 키 사이) 에 얼마나 많은 키가 포함됩니까?
- 주어진 범위에 어떤 키들이 포함됩니까?
- 이러한 질문에 답하는 두 개의 인수를 받는 `size()` 와 `keys()` 메서드는 많은 애플리케이션, 특히 대규모 데이터베이스에서 유용합니다.
- 이러한 쿼리를 처리할 수 있는 능력은 정렬된 심볼 테이블이 실제로 널리 사용되는 주된 이유 중 하나입니다.

#### 예외적인 경우
- 메서드가 키를 반환해야 하는데 테이블에 설명에 맞는 키가 없는 경우, 우리의 관례는 예외를 던지는 것입니다.
    - 합리적인 대안으로, 이러한 경우 `null` 을 반환하는 방법도 있습니다.
- 예를 들어, 테이블이 비어 있으면 `min()`, `max()`, `deleteMin()`, `deleteMax()`, `floor()`, 그리고 `ceiling()` 은 모두 예외를 던집니다.
- `select(k)` 는 **k** 가 **0** 보다 작거나 **size()** 보다 작지 않은 경우(즉, 크거나 같은 경우) 마찬가지로 예외를 던집니다.
#### 단축 메서드
- 기본 API에서 `isEmpty()` 와 `contains()` 를 통해 이미 보았듯이, 우리는 명확성과 클라이언트 코드의 간결성을 위해 API에 일부 중복된 메서드를 유지합니다.
- 본문에서의 간결함을 위해, 별도로 명시되지 않는 한 다음의 기본 구현들이 정렬된 심볼 테이블 API의 모든 구현에 포함되어 있다고 가정합니다.

### 키 동등성 (재검토)
- Java에서의 모범 사례는 모든 `Comparable` 타입에서 `compareTo()` 를 `equals()` 와 일관되게 만드는 것입니다.
- 즉, 주어진 `Comparable` 타입의 모든 값 쌍 **a** 와 **b** 에 대해, `(a.compareTo(b) == 0)` 과 `a.equals(b)` 는 같은 값을 가져야 합니다.
- 잠재적인 모호성을 피하기 위해, 우리는 정렬된 심볼 테이블 구현에서 `equals()` 의 사용을 피합니다.
- 대신, 키를 비교하기 위해 `compareTo()` 만 독점적으로 사용합니다.
- 우리는 불리언 표현식 `a.compareTo(b) == 0` 을 "**a** 와 **b** 가 같은가?" 라는 의미로 받아들입니다.
- 일반적으로, 이러한 테스트는 심볼 테이블에서 **a** 에 대한 검색이 성공적으로 끝났음을 나타냅니다 ( **b** 를 찾음으로써).
- 정렬 알고리즘에서 보았듯이, Java는 일반적으로 사용되는 많은 키 타입에 대해 `compareTo()` 의 표준 구현을 제공하며, 자신만의 데이터 타입을 위한 `compareTo()` 구현을 개발하는 것은 어렵지 않습니다 (**SECTION 2.5** 참조).

### 비용 모델
- 키가 `Comparable` 이 아닌 심볼 테이블에 대해 `equals()` 를 사용하든, `Comparable` 키를 가진 정렬된 심볼 테이블에 대해 `compareTo()` 를 사용하든, 우리는 심볼 테이블 항목을 검색 키와 비교하는 연산을 지칭하기 위해 **compare** 라는 용어를 사용합니다.
- 대부분의 심볼 테이블 구현에서, 이 연산은 내부 루프에 있습니다.
- 그렇지 않은 몇 안 되는 경우에는, 배열 접근도 계산합니다.

> **검색 비용 모델**
> - 심볼 테이블 구현을 연구할 때, 우리는 **compares** (동등성 테스트 또는 키 비교) 의 횟수를 셉니다.
> - 드물게 **compares** 가 내부 루프에 없는 경우, 배열 접근 횟수를 셉니다.

----
### 심볼 테이블 구현

- 심볼 테이블 구현은 일반적으로 기반 자료구조와 `get()` 및 `put()` 의 구현에 의해 특징지어집니다.
- 우리는 본문에서 다른 모든 메서드의 구현을 항상 제공하지는 않는데, 그 이유는 많은 메서드들이 기반 자료구조에 대한 당신의 이해도를 테스트하는 좋은 연습문제가 되기 때문입니다.
- 구현을 구별하기 위해, 우리는 심볼 테이블 구현의 클래스 이름에 설명적인 접두사로 `ST` 를 추가합니다.
- 클라이언트 코드에서는, 특정 구현을 참조하고 싶지 않은 한, 참조 구현을 호출하기 위해 `ST` 를 사용합니다.
- 당신은 이 장과 책의 나머지 부분에서 우리가 제시하고 논의하는 수많은 클라이언트와 심볼 테이블 구현의 맥락에서 API의 메서드에 대한 근거를 점차 더 잘 느끼게 될 것입니다.

---

### 정렬되지 않은 연결 리스트에서의 순차 탐색
- 심볼 테이블의 기반 자료구조에 대한 한 가지 간단한 선택지는 키와 값을 포함하는 노드의 연결 리스트입니다.
- `get()` 을 구현하기 위해, 우리는 리스트를 스캔하며 `equals()` 를 사용하여 탐색 키를 리스트의 각 노드에 있는 키와 비교합니다.
    - 만약 일치하는 것을 찾으면, 연관된 값을 반환합니다.
    - 그렇지 않으면, `null` 을 반환합니다.
- `put()` 을 구현하기 위해, 우리는 또한 리스트를 스캔하며, `equals()` 를 사용하여 클라이언트 키를 리스트의 각 노드에 있는 키와 비교합니다.
    - 만약 일치하는 것을 찾으면, 그 키와 연관된 값을 두 번째 인수로 주어진 값으로 업데이트합니다.
    - 그렇지 않으면, 주어진 키와 값으로 새로운 노드를 만들어 리스트의 맨 앞에 삽입합니다.
- 이 방법은 **순차 탐색** 으로 알려져 있습니다: 우리는 탐색 키와의 일치를 테스트하기 위해 `equals()` 를 사용하여 테이블의 키를 차례로 고려하여 탐색합니다.
    
- **알고리즘 3.1** (`SequentialSearchST`)은 우리의 기본 심볼 테이블 API의 구현으로, **CHAPTER 1** 에서 기본 자료구조를 위해 사용했던 표준적인 리스트 처리 메커니즘을 사용합니다.
- 우리는 `size()`, `keys()`, 그리고 `eager delete()` 의 구현을 연습문제로 남겨두었습니다.
    - 연결 리스트 자료구조와 기본 심볼 테이블 API에 대한 당신의 이해를 공고히 하기 위해 이 연습문제들을 풀어보는 것을 권장합니다.

```cpp
#pragma once

namespace gb {
	template <typename Key, typename Value>
	class SequentialSearchST {
	private:
		// 연결 리스트 노드를 위한 private 중첩 클래스
		struct Node {
			Key key;
			Value value;
			Node* next;

			// 생성자
			Node(const Key& key, const Value& value, Node* next)
				: key(key), value(value), next(next) {
			}
		};

		Node* first_node; // 연결 리스트의 첫 번째 노드

	public:
		// 생성자: 빈 심볼 테이블을 생성합니다.
		SequentialSearchST() : first_node(nullptr) {}

		// 소멸자: 동적으로 할당된 모든 노드를 해제합니다.
		~SequentialSearchST() {
			Node* current = first_node;
			while (current != nullptr) {
				Node* temp = current;
				current = current->next;
				delete temp;
			}
		}

		/**
		 * @brief 주어진 키와 연관된 값을 반환합니다.
		 * @param key 검색할 키
		 * @return 키와 연관된 값에 대한 포인터. 키가 테이블에 없으면 nullptr를 반환합니다.
		 */
		Value* get(const Key& key) {
			// 탐색 히트: 키를 찾아 연관된 값을 반환합니다.
			for (Node* x = first_node; x != nullptr; x = x->next) {
				if (key == x->key) {
					return &(x->value); // 탐색 히트
				}
			}
			return nullptr; // 탐색 미스
		}

		/**
		 * @brief 키-값 쌍을 테이블에 추가합니다.
		 * 키가 이미 존재하면 값을 업데이트하고, 그렇지 않으면 새로운 노드를 추가합니다.
		 * @param key 키
		 * @param value 값
		 */
		void put(const Key& key, const Value& value) {
			// 탐색 히트: 키를 찾아 값을 업데이트합니다.
			for (Node* x = first_node; x != nullptr; x = x->next) {
				if (key == x->key) {
					x->value = value;
					return;
				}
			}
			// 탐색 미스: 새로운 노드를 리스트의 맨 앞에 추가합니다.
			first_node = new Node(key, value, first_node);
		}
	};
}
```

![[Pasted image 20250824181146.png]]

- 이 연결 리스트 기반 구현이 우리의 샘플 클라이언트처럼 큰 테이블을 필요로 하는 애플리케이션을 처리할 수 있을까요?
- 우리가 언급했듯이, 심볼 테이블 알고리즘을 분석하는 것은 정렬 알고리즘을 분석하는 것보다 더 복잡합니다. 주어진 클라이언트에 의해 호출될 수 있는 연산의 순서를 특징짓기가 어렵기 때문입니다.
- 가장 흔한 상황은 탐색과 삽입 패턴이 예측 불가능하지만, 그렇다고 확실히 무작위는 아니라는 것입니다.
- 이러한 이유로, 우리는 **최악의 경우 성능**에 세심한 주의를 기울입니다.
- 간결함을 위해, 성공적인 탐색을 **탐색 히트(search hit)**, 실패한 탐색을 **탐색 미스(search miss)** 라는 용어로 지칭합니다.
    

> **Proposition A.** N개의 키-값 쌍을 가진 (정렬되지 않은) 연결 리스트 심볼 테이블에서 **탐색 미스**와 **삽입**은 모두 최악의 경우 **N** 번의 비교를 필요로 하고, **탐색 히트**는 최악의 경우 **N** 번의 비교를 필요로 합니다. 특히, 초기에 비어있는 연결 리스트 심볼 테이블에 **N** 개의 고유한 키를 삽입하는 것은 ~N^2/2 번의 비교를 사용합니다.
> **Proof:** 리스트에 없는 키를 검색할 때, 우리는 테이블의 모든 키를 검색 키와 비교하여 테스트합니다. 중복 키를 허용하지 않는 우리의 정책 때문에, 매 삽입 전에 이러한 탐색을 수행해야 합니다.
> **Corollary.** 초기에 비어있는 연결 리스트 심볼 테이블에 **N** 개의 고유한 키를 삽입하는 것은 ~N2/2 번의 비교를 사용합니다.

- 테이블 **안에** 있는 키에 대한 검색이 반드시 선형 시간이 걸릴 필요는 없다는 것은 사실입니다.
- 한 가지 유용한 척도는 테이블에 있는 모든 키를 검색하는 데 드는 총비용을 계산한 다음, `N` 으로 나누는 것입니다.
- 이 양은 테이블의 각 키를 검색할 확률이 동일하다는 조건 하에서, 검색에 필요한 평균 비교 횟수와 정확히 일치합니다.
- 우리는 이러한 검색을 **무작위 탐색 히트 (random search hit)** 라고 부릅니다.
- 클라이언트의 검색 패턴이 무작위일 가능성은 낮지만, 종종 이 모델에 의해 잘 설명됩니다.
- **무작위 탐색 히트**에 대한 평균 비교 횟수가 `~N/2` 임을 보이는 것은 쉽습니다.
    - **알고리즘 3.1**의 `get()` 메서드는 첫 번째 키를 찾는 데 1번, 두 번째 키를 찾는 데 2번의 비교를 사용하는 식으로 진행되어, 평균 비용은 `(1 + 2 + ... + N) / N = (N + 1)/2 ~ N/2` 가 됩니다.
- 이 분석은 순차 탐색을 사용하는 연결 리스트 구현이 거대한 문제를 해결하는 데 사용되기에는 너무 느리다는 것을 강력하게 시사합니다.

### 연습 문제
- 다음 ST API를 참고하여, 구현되지 않은 메서드들을 구현해봅시다.

![[Pasted image 20250824172039.png]]


----

### 정렬된 배열에서의 이진 탐색
- 다음으로, 우리는 정렬된 심볼 테이블 API의 전체 구현을 고려합니다.
- 기반 자료구조는 키를 위한 배열과 값을 위한 배열, 이렇게 한 쌍의 병렬 배열입니다.
- **알고리즘 3.2** (`BinarySearchST`)는 `Comparable` 키를 배열에 순서대로 유지한 다음, `get()` 및 다른 연산들의 빠른 구현을 위해 배열 인덱싱을 사용합니다.
- 이 구현의 핵심은 `rank()` 메서드로, 주어진 키보다 작은 키의 수를 반환합니다.
- `get()` 의 경우, `rank` 는 키가 테이블에 있다면 어디서 찾을 수 있는지 (그리고 없다면, 테이블에 없다는 것을) 정확하게 알려줍니다.
- `put()` 의 경우, `rank` 는 키가 테이블에 있을 때 값을 어디서 업데이트해야 하는지, 그리고 키가 테이블에 없을 때 키를 어디에 두어야 하는지를 정확하게 알려줍니다.
    - 우리는 공간을 만들기 위해 더 큰 모든 키를 한 칸씩 뒤로 이동시킨 다음 (뒤에서부터 앞으로 작업), 주어진 키와 값을 각 배열의 적절한 위치에 삽입합니다.
- 다시 한번, 우리의 테스트 클라이언트의 추적과 함께 `BinarySearchST` 를 연구하는 것은 이 자료구조에 대한 유익한 소개가 될 것입니다.
- 이 코드는 키와 값의 병렬 배열을 유지합니다.
- **CHAPTER 1** 에서의 제네릭 스택과 큐 구현과 마찬가지로, 이 코드는 `Comparable` 타입의 `Key` 배열과 `Object` 타입의 `Value` 배열을 생성해야 하고, 생성자에서 이들을 다시 `Key[]` 와 `Value[]` 로 캐스팅해야 하는 불편함을 수반합니다.
- 늘 그렇듯이, 우리는 배열 크기 조절을 사용하여 클라이언트가 배열의 크기에 대해 신경 쓰지 않도록 할 수 있습니다 (곧 보게 되겠지만, 이 방법은 큰 배열에 사용하기에는 너무 느리다는 점에 유의해야 합니다).

![[Pasted image 20250824182659.png]]

### ALGORITHM 3.2

```cpp
#pragma once

namespace gb {

	/**
	 * @brief 정렬된 배열과 이진 탐색을 사용하는 심볼 테이블 구현
	 * @tparam Key 키의 타입. 비교 가능해야 합니다 (<, >, == 연산자 필요).
	 * @tparam Value 값의 타입
	 */
	template <typename Key, typename Value>
	class BinarySearchST {
	private:
		Key* keys;      // 키를 저장하는 배열
		Value* values;  // 값을 저장하는 배열
		int count;      // 현재 저장된 키-값 쌍의 수
		int capacity;   // 배열의 현재 용량

	public:
		/**
		 * @brief 주어진 용량으로 심볼 테이블을 생성합니다.
		 * @param initial_capacity 초기 배열 용량
		 */
		explicit BinarySearchST(int initial_capacity) {
			capacity = initial_capacity;
			keys = new Key[capacity];
			values = new Value[capacity];
			count = 0;
		}

		// 소멸자
		~BinarySearchST() {
			delete[] keys;
			delete[] values;
		}

		// 복사 및 대입을 금지하여 메모리 문제를 방지합니다.
		BinarySearchST(const BinarySearchST&) = delete;
		BinarySearchST& operator=(const BinarySearchST&) = delete;

		int size() const {
			return count;
		}

		int rank(const Key& key) const {
			...
		}

		/**
		 * @brief 주어진 키와 연관된 값을 반환합니다.
		 * @param key 검색할 키
		 * @return 값에 대한 포인터. 키가 없으면 nullptr.
		 */
		Value* get(const Key& key) {
			if (is_empty()) {
				return nullptr;
			}
			int i = rank(key);
			if (i < count && keys[i] == key) {
				return &values[i]; // 탐색 히트
			}
			return nullptr; // 탐색 미스
		}

		/**
		 * @brief 키-값 쌍을 테이블에 추가합니다.
		 * @param key 키
		 * @param value 값
		 */
		void put(const Key& key, const Value& value) {
			int i = rank(key);

			// 탐색 히트: 키가 이미 존재하면 값을 업데이트
			if (i < count&& keys[i] == key) {
				values[i] = value;
				return;
			}

			// 탐색 미스: 새로운 키-값 쌍을 삽입
			if (count == capacity) {
				resize(2 * capacity);
			}

			// rank 이후의 모든 요소를 한 칸씩 뒤로 이동
			for (int j = count; j > i; --j) {
				keys[j] = keys[j - 1];
				values[j] = values[j - 1];
			}

			keys[i] = key;
			values[i] = value;
			count++;
		}
	};

} // namespace gb
```


### 이진 탐색 (Binary search)

- 우리가 정렬된 배열에 키를 유지하는 이유는, 탐색에 필요한 비교 횟수를 획기적으로 줄이기 위함입니다.
- 이를 위해 고전적이고 유서 깊은 **이진 탐색 (binary search)** 알고리즘을 사용합니다.
    - 이는 **CHAPTER 1** 에서 예제로 사용했던 것입니다.
- 우리는 탐색 키를 포함할 수 있는 하위 배열의 범위를 정하는, 정렬된 키 배열에 대한 인덱스들을 유지합니다.
- 탐색을 위해, 하위 배열의 중간에 있는 키와 탐색 키를 비교합니다.
    - 만약 탐색 키가 중간 키보다 작으면, 하위 배열의 왼쪽 절반을 탐색합니다.
    - 만약 탐색 키가 중간 키보다 크면, 하위 배열의 오른쪽 절반을 탐색합니다.
    - 그렇지 않으면, 중간 키가 탐색 키와 같은 경우입니다.

```cpp
template <typename Item, typename Key>
int rank(const Key& key, const Item* keys_arr, int lo, int hi) {
    if (hi < lo) {
        return lo;
    }
    int mid = lo + (hi - lo) / 2;
    if (key < keys_arr[mid]) {
        return rank(key, keys_arr, lo, mid - 1);
    } else if (key > keys_arr[mid]) {
        return rank(key, keys_arr, mid + 1, hi);
    } else {
        return mid;
    }
}
```

- `rank()` 코드는 방금 논의한 심볼-테이블 구현을 완성하기 위해 이진 탐색을 사용합니다.
- 이 구현은 신중하게 연구할 가치가 있습니다.
    - 이를 연구하기 위해, 우리는 왼쪽에 있는 동일한 기능의 재귀 코드부터 시작합니다.
- `rank(key, 0, N-1)` 호출은 **ALGORITHM 3.2** 의 비재귀적 구현에 대한 호출과 동일한 비교 시퀀스를 수행합니다.
    - 하지만 이 대안 버전은 **SECTION 1.1** 에서 논의된 바와 같이 알고리즘의 구조를 더 잘 보여줍니다.
- 이 재귀적인 `rank()` 는 다음 속성들을 보존합니다:
    > - 만약 키가 테이블에 있다면, `rank()` 는 테이블에서의 인덱스를 반환하며, 이는 해당 키보다 작은 키들의 개수와 같습니다.
    > - 만약 키가 테이블에 없다면, `rank()` 는 **또한** 해당 키보다 작은 키들의 개수를 반환합니다.
    
- 시간을 내어 **ALGORITHM 3.2** 의 비재귀적 `rank()` 가 예상대로 작동하는지 스스로 확인해보는 것은 모든 프로그래머에게 가치 있는 연습입니다.
    - (재귀 버전과 동일하다는 것을 증명하거나, 루프가 항상 `lo` 의 값으로 종료되며 이 `lo` 값이 정확히 해당 키보다 작은 테이블 내 키의 수와 같다는 것을 직접 증명하는 방식으로)
    - ( **힌트**: `lo` 는 0 에서 시작하며 절대 감소하지 않는다는 점에 유의하세요.)


### ALGORITHM 3.2 (계속)

```cpp
		int rank(const Key& key) const {
			int lo = 0, hi = count - 1;
			while (lo <= hi) {
				int mid = lo + (hi - lo) / 2;
				if (key < keys[mid]) {
					hi = mid - 1;
				}
				else if (key > keys[mid]) {
					lo = mid + 1;
				}
				else {
					return mid; // 키를 찾음
				}
			}
			return lo; // 키를 못 찾은 경우, 키가 삽입될 위치(lo)가 순위가 됨
		}
```

![[Pasted image 20250828203903.png]]

### ALGORITHM 3.2 (계속)

```cpp
		const Key& min() const {
			if (is_empty()) {
				throw std::out_of_range("Symbol table is empty");
			}
			return keys[0];
		}

		const Key& max() const {
			if (is_empty()) {
				throw std::out_of_range("Symbol table is empty");
			}
			return keys[count - 1];
		}
		
		const Key& select(int k) const {
			if (k < 0 || k >= count) {
				throw std::out_of_range("Index is out of bounds");
			}
			return keys[k];
		}

		const Key* ceiling(const Key& key) const {
			int i = rank(key);
			if (i == count) {
				return nullptr; // 모든 키가 key보다 작음
			}
			return &keys[i];
		}

		const Key* floor(const Key& key) const {
			...
		}

		/**
		 * @brief 주어진 키와 그와 연관된 값을 삭제합니다.
		 */
		void delete_key(const Key& key) {
			...
		}
```

### 이진 탐색의 분석 (Analysis of binary search)

- `rank()` 의 재귀적 구현은 이진 탐색이 빠른 탐색을 보장한다는 즉각적인 논증으로 이어집니다.
    - 왜냐하면 비교 횟수에 대한 상한을 설명하는 순환 관계 (recurrence relation) 에 해당하기 때문입니다.

> **명제 B.** N 개의 키를 가진 정렬된 배열에서의 이진 탐색은, 탐색의 성공 여부와 관계없이 최대 lgN+1 번의 비교만을 사용합니다.


#### 증명 (Proof)
- 이 분석은 병합 정렬 (mergesort) 의 분석 (**CHAPTER 2** 의 **명제 F**) 과 유사하지만 더 간단합니다.
- - 크기가 `N` 인 심볼 테이블에서 키를 탐색하는 데 필요한 비교 횟수를 `C(N)` 이라고 합시다.
    - 우리는 `C(0) = 0`, `C(1) = 1` 이라는 것을 알고 있으며, `N > 0` 에 대해 재귀적 메소드를 직접적으로 반영하는 다음의 순환 관계를 작성할 수 있습니다:
        - `C(N) ≤ C(⌊N/2⌋) + 1`
    - 탐색이 왼쪽으로 가든 오른쪽으로 가든, 하위 배열의 크기는 최대 `⌊N/2⌋` 가 됩니다.
    - 그리고 우리는 동등성 (**equality**) 을 확인하고 왼쪽으로 갈지 오른쪽으로 갈지 선택하기 위해 한 번의 비교를 사용합니다.
- 이 순환 관계를 푸는 것은 어렵지 않습니다.
    - 먼저, `N` 이 2의 거듭제곱보다 1 작은 수 (가령 `N = 2ⁿ - 1`) 일 때, `⌊N/2⌋ = 2ⁿ⁻¹ - 1` 이므로 다음을 얻습니다:
        - `C(2ⁿ - 1) ≤ C(2ⁿ⁻¹ - 1) + 1`
    - 오른쪽 항에 동일한 방정식을 적용하면 다음을 얻습니다:
        - `C(2ⁿ - 1) ≤ C(2ⁿ⁻² - 1) + 1 + 1`
    - 이전 단계를 `n-2` 번 추가로 반복하면 다음을 얻습니다:
        - `C(2ⁿ - 1) ≤ C(2ⁿ) + n`
    - 이는 우리에게 다음과 같은 해답을 줍니다:
        - `C(N) = C(2ⁿ) ≤ n + 1 < lg N + 1`
- 일반적인 `N` 에 대한 정확한 해는 더 복잡하지만, 모든 `N` 값에 대해 이 명시된 속성을 확립하기 위해 이 논증을 확장하는 것은 어렵지 않습니다.
    
- 이진 탐색을 통해, 우리는 **로그 시간 (logarithmic-time) 탐색**을 보장받을 수 있습니다.
- 로그 시간 탐색을 보장함에도 불구하고, `BinarySearchST` 는 `put()` 메소드가 너무 느리기 때문에 `FrequencyCounter` 와 같은 클라이언트를 사용하여 거대한 문제를 해결하는 것을 여전히 불가능하게 합니다.
- 이진 탐색은 비교 횟수는 줄여주지만, 실행 시간 자체를 줄여주지는 않습니다.
    - 왜냐하면 이진 탐색을 사용하더라도, 정렬된 배열에 심볼 테이블을 구축하는 데 필요한 배열 접근 횟수는 키가 무작위로 정렬된 경우 배열 크기에 대해 **이차 시간 (quadratic)** 이라는 사실을 바꾸지 않기 때문입니다.
    - (그리고 키가 무작위는 아니지만, 이 모델에 의해 잘 설명되는 일반적인 실제 상황에서도 마찬가지입니다.)

![[Pasted image 20250828204725.png]]

- 방금 제시된 `ceiling()` 의 구현은 `rank()` 에 대한 단일 호출을 기반으로 합니다.
- 그리고 기본적으로 두 개의 인자를 받는 `size()` 구현은 `rank()` 를 두 번 호출하므로, 이 증명은 이러한 연산들 (`floor()` 포함) 이 보장된 **로그 시간 (logarithmic-time)** 내에 지원된다는 것을 또한 입증합니다.
    - (`min()`, `max()`, 그리고 `select()` 는 **상수 시간 (constant-time)** 연산입니다.)

![[Pasted image 20250828205153.png]]
![[Pasted image 20250828205142.png]]

---
### 미리보기 (Preview)

- 이진 탐색은 일반적으로 순차 탐색보다 훨씬 뛰어나며 수많은 실제 애플리케이션에서 **선택되는 방법 (method of choice)** 입니다.
- 정적 테이블 (`insert` 연산이 허용되지 않음) 의 경우, **CHAPTER 1** 에서 고려했던 이진 탐색 버전처럼 테이블을 초기화하고 정렬하는 것이 가치 있습니다 (99페이지 참조).
- 대부분의 탐색이 이루어지기 전에 대부분의 키-값 쌍을 미리 알고 있는 경우 (애플리케이션에서 흔한 상황) 에도, `BinarySearchST` 에 테이블을 초기화하고 정렬하는 생성자를 추가하는 것이 좋습니다 (**연습문제 3.1.12** 참조).
- 그럼에도 불구하고, 이진 탐색은 다른 많은 애플리케이션에서는 사용하기에 **비현실적 (infeasible)** 입니다.
- 우리가 강조했듯이, 일반적인 현대의 탐색 클라이언트는 **탐색과 삽입 모두**에 대한 빠른 구현을 지원할 수 있는 심볼 테이블을 필요로 합니다.
    - 즉, 예측할 수 없는 패턴으로 키-값 쌍을 삽입 (그리고 아마도 제거) 하고, 그사이에 탐색이 혼합될 수 있는 거대한 테이블을 구축할 수 있어야 합니다.
- 아래 표는 이 섹션에서 고려된 기본 심볼 테이블 구현들의 성능 특성을 요약합니다.
    - 표의 항목들은 비용의 **주요 항 (leading term)** 을 나타내며 (이진 탐색의 경우 배열 접근 횟수, 나머지는 비교 횟수), 이는 실행 시간의 **증가 차수 (order of growth)** 를 의미합니다.

![[Pasted image 20250828205216.png]]

- 핵심 질문은 **탐색과 삽입 모두**에 대해 로그 성능을 달성하는 알고리즘과 자료 구조를 고안할 수 있는지 여부입니다.
- 그 대답은 압도적인 **"예 (yes)!"** 입니다.
    - 그 답을 제공하는 것이 이 챕터의 주요 추진력입니다.
- **CHAPTER 2** 에서 논의된 빠른 정렬 기능과 더불어, 빠른 심볼-테이블 탐색/삽입은 알고리즘학의 가장 중요한 기여 중 하나이며, 우리가 지금 누리고 있는 풍부한 컴퓨팅 인프라 개발을 향한 가장 중요한 단계 중 하나입니다.
- 어떻게 이 목표를 달성할 수 있을까요?
    - 효율적인 삽입을 지원하기 위해서는, 연결 구조 (linked structure) 가 필요한 것처럼 보입니다.
    - 그러나 단일 연결 리스트는 이진 탐색의 사용을 배제합니다. 왜냐하면 이진 탐색의 효율성은 어떤 하위 배열의 중간 지점으로든 갈 수 있는 능력에 달려있기 때문입니다.
        - (인덱싱을 통해 빠르게 접근하는 능력 말입니다. 그리고 단일 연결 리스트의 중간으로 가는 유일한 방법은 링크를 따라가는 것입니다).
- 이진 탐색의 효율성과 연결 구조의 유연성을 결합하기 위해서는, 우리는 더 복잡한 자료 구조가 필요합니다.
    - 그 조합은 다음 두 섹션의 주제인 **이진 탐색 트리 (binary search trees)** 와 **SECTION 3.4** 의 주제인 **해시 테이블 (hash tables)** 에 의해 제공됩니다.
- 우리는 이 챕터에서 여섯 가지 심볼-테이블 구현을 고려하므로, 간단한 미리보기가 필요합니다.
    - 아래 표는 자료 구조의 목록이며, 각 자료 구조를 특정 애플리케이션에 사용하는 것에 대한 찬반의 주된 이유가 함께 제시되어 있습니다.
    - 그것들은 우리가 고려하는 순서대로 나타납니다.
- 알고리즘과 구현의 속성에 대해서는 논의하면서 더 자세히 다루겠지만, 이 표의 간략한 특징들은 여러분이 학습하는 동안 그것들을 더 넓은 맥락에서 유지하는 데 도움이 될 것입니다.
- 핵심은 우리에게 수많은 애플리케이션에서 큰 효과를 내며 사용될 수 있고 또 사용되고 있는 여러 빠른 심볼-테이블 구현들이 있다는 것입니다.

![[Pasted image 20250828205234.png]]

