
# 2. 정렬

## 2.3 퀵 정렬

- 이 절의 주제는 그 어느 정렬 알고리즘보다도 가장 널리 사용되고 있는 **퀵 정렬**입니다.
- 퀵 정렬이 유명한 이유는 다음과 같습니다:
	- 구현하기 쉽습니다.
	- 다양한 형태의 입력 데이터들에도 잘 동작합니다.
	- 전형적인 응용 상황에서 다른 정렬 알고리즘보다 훨씬 더 빠릅니다.
	- 추가적인 메모리를 사용하지 않습니다.
- 반면, 아주 중요한 단점이 존재합니다.
	- **부주의한 구현으로 기대 이하의 성능을 보이기 쉽습니다.**
- 잘못된 구현 때문에 제곱 시간의 성능으로 떨어진 사례가 매우 많이 알려져 있습니다.
	- 우리는 그러한 실수로부터 교훈을 얻고, 여러 가지 개선 사항들을 알아볼 것입니다.


### 기본 알고리즘

- 퀵 정렬 역시 병합 정렬과 마찬가지로 분할 정복을 사용합니다.
	- 배열을 부분 배열로 분할한 뒤, 각각의 부분 배열을 독립적으로 정렬합니다.
- 퀵 정렬은 병합 정렬과 상보적 관계입니다.
	- 병합 정렬은 배열을 두 개의 부분 배열로 나누어 각각을 정렬한 다음 정렬된 부분 배열들을 다시 전체 배열로 합치며 정렬합니다.
	- 반면, 퀵 정렬은 두 배열을 나누되, **각각의 배열이 정렬된다면 전체 배열도 이미 정렬된 상태가 되도록 나눕니다.**
	- 병합 정렬은 전체 배열에 대한 작업을 수행하기 이전에 두 개의 재귀 호출을 수행합니다.
	- 반면, 퀵 정렬은 **전체 배열에 대한 작업을 수행한 이후 두 개의 재귀 호출을 수행합니다.**


![[03_010_QuickSortOverview]]

```c++

template <typename T>
class QuickSort : public Sort<T>
{
public:
	/**
	 * @brief 배열을 퀵 정렬합니다.
	 * @param arr 정렬할 배열
	 * @param n 배열의 크기
	 */
	void sort(T arr[], int n) override
	{
		// 입력 의존성을 없애기 위해 배열을 무작위로 섞습니다.
		unsigned seed = 
			std::chrono::system_clock::now()
			.time_since_epoch()
			.count();

		std::shuffle(
			arr, 
			arr + n, 
			std::default_random_engine(seed)
		);

		// 재귀 정렬을 시작합니다.
		do_sort(arr, 0, n - 1);
	}

private:
	/**
	 * @brief arr[low..high] 범위를 재귀적으로 정렬합니다.
	 */
	void do_sort(T arr[], int low, int high)
	{
		// 기저 사례: 부분 배열의 크기가 1 이하이면 종료
		if (high <= low)
		{
			return;
		}

		// 파티션을 수행하고 피벗의 최종 위치를 받습니다.
		int j = partition(arr, low, high);

		// 피벗을 기준으로 나눠진 두 부분 배열에 대해 재귀 호출
		do_sort(arr, low, j - 1);
		do_sort(arr, j + 1, high);
	}

```

![[03_020_QuickSortTrace]]


- 이 방법의 핵심은 다음 세 가지 조건을 유지하는 배열의 재배열 및 분할 과정에 있습니다:
	- 항목 a\[j]의 j는 전체 배열상에서 최종적으로 결정된 정렬 위치이다.
	- a\[lo]에서 a\[j-1]에 이르는 항목 중에 a\[j]보다 큰 항목은 없다.
	- a\[j+1]에서 a\[hi]에 이르는 항목 중에 a\[j]보다 작은 항목은 없다.
- 분할만으로 완전한 정렬을 완성합니다. 그리고 이 방법을 재귀적으로 적용합니다.

- 한 번의 분할 작업마다 항목 하나씩 올바른 위치가 결정되기 때문에, 이 알고리즘이 올바르게 정렬한다는 것을 귀납법을 이용해 어렵지 않게 정규적으로 증명할 수 있습니다.
	- 좌우 부분 배열이 각각 올바르게 정렬되어 있다면, 
	- 부분 배열의 분할 기준 항목의 좌측에는 그 항목보다 큰 항목이 없고, 
	- 우측에는 그 항목보다 작은 항목이 없기 때문에, 
	- 좌우 부분 배열로 이루어지는 결과 배열도 전체적으로 올바르게 정렬된 상태가 됩니다.


#### 분할 알고리즘

- 알고리즘을 완성하기 위해 분할 메서드를 구현해야 합니다.
- 분할 방법에는 다음과 같은 전략을 사용합니다:
	- 먼저, 임의의 항목 a\[lo]를 분할 기준 항목으로 선택합니다.
	- 분할 기준 항목은 종국적인 정렬 상태에서, 자신이 위치해야 할 곳으로 옮겨집니다.
	- 옮기는 방법은 다음과 같습니다:
		- 배열의 왼쪽 끝부터 분할 기준 항목보다 크거나 같은 항목을 만날 때까지 스캔합니다.
		- 배열의 오른쪽 끝부터 분할 기준 항목보다 작거나 같은 항목을 만날 때까지 스캔합니다.
		- 이렇게 찾은 두 항목은 최종 정렬 위치에서 벗어나 있기 때문에 둘을 교환합니다.
		- 위를 반복하며 계속 양쪽의 스캔 인덱스를 진행해 나갑니다.
		- 양쪽의 스캔 인덱스가 교차하게 된다면, 분할 기준 항목 a\[lo]를 왼쪽편 항목들에서 가장 오른편에 있는 항목a\[j]와 교환하고 그 인덱스 j를 리턴합니다.

![[03_030_PartitioningTrace]]

```c++
int partition(T arr[], int lo, int hi)
{
	int i = lo;
	int j = hi + 1;
	T pivot = arr[lo]; // 첫 번째 원소를 피벗으로 선택

	while (true)
	{
		// 왼쪽에서 오른쪽으로 스캔: 피벗보다 크거나 같은 원소를 찾습니다.
		i++;
		while (i <= hi && arr[i] < pivot)
		{
			i++;
		}
		
		// 오른쪽에서 왼쪽으로 스캔: 피벗보다 작거나 같은 원소를 찾습니다.
		j--;
		while (j >= lo && arr[j] > pivot)
		{
			j--;
		}
		
		// 포인터가 교차되면 루프를 탈출합니다.
		if (i >= j)
		{
			break;
		}

		// 찾은 두 원소의 위치를 교환합니다.
		this->swap(arr, i, j);
	}

	// 피벗(arr[lo])을 최종 위치(j)로 이동시킵니다.
	this->swap(arr, lo, j);

	// 피벗의 최종 위치를 반환합니다.
	return j;
	```
	

### 퀵 정렬을 구현할 때 주의사항

#### In-place 분할
- 추가적인 작업용 배열을 사용하면 구현이 쉬워집니다.
- 하지만 분할된 배열을 원본 배열에 복제해 넣는 오버헤드 비용을 상쇄할 만큼 쉬워진다고 보기는 어렵습니다.
- 이는 정렬 수행 시간을 급격하게 늘리는 원인이 되며, in-place 분할으로 구현하려 노력해야 할 것입니다.

#### 경계선 넘지 않기
- 만약 분할 기준 항목이 가장 작은 키 또는 가장 큰 키를 가졌다면 스캔 중에 배열의 왼쪽 또는 오른쪽 끝을 넘어가지 않도록 주의해야 합니다.

#### 무작위성의 유지
- 퀵 정렬은 데이터의 입력 상태에 따라 실행 시간이 상이하므로 반드시 무작위성을 유지해야 합니다.
- 따라서 퀵 정렬을 시작하기 이전에 정렬을 섞는 단계가 필요합니다.
- 이는 알고리즘의 실행 시간을 예측할 수 있게 하는데 중요한 역할을 합니다.
- 무작위성을 유지하는 또 다른 방법은 partition() 안에서 분할 기준 항목을 무작위로 선택하는 것입니다.

#### 루프의 종료
- 경험 많은 프로그래머라면 어떤 루프이든 반드시 종료 조건을 가지도록 하는데 많은 주의를 기울입니다.
- 포인터가 서로 교차했는지 올바르게 검사하는 것이 언뜻 보기에는 쉬워 보일 수 있습니다.
- 하지만 흔히 발생하는 실수 중 하나로 분할 기준 항목과 동일한 키를 가지는 항목이 배열에 있을 수 있다는 것을 고려하지 못하기도 합니다.

#### 분할 기준 항목과 동일한 키를 가지는 배열 항목 다루기
- 가장 좋은 방법은: 
	- 좌측을 스캔할 때는 분할 기준 항목보다 크거나 같은 항목이 나오면 스캔을 중단하고,
	- 우측을 스캔할 때는 분할 기준 항목보다 작거나 같은 항목이 나올 때 스캔을 중단하는 것입니다.
- 비록 이러한 방식이 분할 기준 항목과 키가 같은 항목 간에 불필요한 교환을 유발하기는 하지만, 특정 활용 환경에서 제곱 시간 성능으로 떨어지는 것을 막기 위해서는 감수해야 할 오버헤드입니다.
- 배열에 동일한 키 값을 가진 항목들이 대단히 많을 경우에는 어떻게 대처해야 하는지에 대해서도 나중에 살펴볼 것입니다.


#### 재귀 호출의 경로
- 경험 많은 프로그래머라면 어떤 재귀 호출이든 반드시 종료 조건을 가지도록 하는데 많은 주의를 기울입니다.
- 퀵 정렬의 재귀 호출도 마찬가지입니다.
	- 퀵 정렬의 구현에서 가장 흔하게 일어나는 실수는 무한 루프에 빠지는 것입니다.
	- 매 루프마다 반드시 항목 하나씩은 정렬 위치가 결정되도록 해야 하는데, 
	- 그렇게 하지 못하여 배열의 가장 작은 또는 가장 큰 항목을 기준으로 하여 분할 작업을 할 때 종료 조건에 도달하지 못하는 경우가 있습니다.


### 성능 특성

- 퀵 정렬은 많은 연구자들을 통해 매우 주의 깊은 수학적 분석이 수행되어 왔습니다.
	- 따라서, 퀵 정렬의 성능에 대해서는 **매우 정확하게** 기술할 수 있습니다.

- 퀵 정렬은 내부 루프(분할 메서드에 있는)는 인덱스를 증가시켜가며 어떤 고정된 값과 배열 항목의 값을 비교합니다.
	- 이는 매우 단순하며, 퀵 정렬을 빠르게 하는 요인 중 하나입니다.
- 퀵 정렬은 적은 수의 비교 연산을 합니다.
	- 퀵 정렬의 성능은 종국적으로 배열을 얼마나 잘 분할하느냐에 달려 있습니다.
		- 큰 무작위 배열을 분할하면 두 개의 작은 무작위 배열이 생깁니다.
		- 그런데 실제 분할되는 기준은 배열의 어느 항목이든 동일한 확률을 가집니다.
	- 퀵 정렬에서 가장 이상적인 분할은 배열이 정확히 절반으로 나누어지는 것입니다.
	- 그리고 수학적으로, 평균적인 분할 위치는 배열의 가운데입니다.

- 퀵 정렬에 많은 장점이 있지만 한 가지 잠재적인 문제점이 있습니다.
	- 분할이 균형 있게 이루어지지 않을 경우 극단적으로 비효율이 될 수 있습니다.
		- 예를 들어 첫 번째로 분할된 부분 배열이 배열에서 가장 작은 항목이고,
		- 두 번째로 분할된 부분 배열이 배열에서 두 번째로 가장 작은 항목인 형태로
		- 계속해서 반복되어 매 분할 작업 호출마다 단 한 개의 항목만 처리되는 상황이 나올 수 있습니다.
	- 따라서 입력 배열을 정렬하기 전에 무작위로 섞는 이유는 이러한 상황을 피하기 위해서입니다.

### 알고리즘의 개선

- 퀵 정렬은 1960년대 찰스 앤서니 리처드 호어(C. A. R. Hoare)에 의해 개발되었습니다.
- 그 이후 많은 사람에 의해 연구되고 개선되어 왔으며, 여전히 퀵 정렬을 더 개선해보려는 노력을 하고 싶을 수 있습니다.
	- 하지만 리처드 호어가 처음 퀵 정렬을 공표한 이후로 많은 사람들이 개선 아이디어를 제안했지만 온전하게 성공한 것은 많지 않습니다.
	- 한쪽 부분의 개선이 다른 쪽 부분에 부작용을 일으키기 쉽기 때문입니다.
	- 앞으로 살펴볼 몇몇 시도들은 꽤 효과적으로 개선에 성공하였습니다.

#### 삽입 정렬로의 컷오프 전환
- 거의 모든 재귀 알고리즘이 그렇듯이, 다음의 두 가지 관찰을 바탕으로 단서를 찾으면 퀵 정렬의 성능을 쉽게 개선할 수 있습니다.
	- 작은 부분 배열에서는 퀵 정렬이 삽입 정렬보다 느리다.
	- 재귀적 동작으로 인해, 작은 부분 배열에 대해서도 반드시 퀵 정렬의 sort()가 호출된다.
- 따라서, 작은 부분 배열에 대해서 알고리즘을 삽입 정렬로 전환한다면, 성능 개선이 있을 수 있습니다.

#### 3-중앙값 분할
- 퀵 정렬의 성능을 개선할 수 있는 두 번째 쉬운 방법은 분할 기준 항목을 정할 때 작은 크기의 샘플에서 그 중앙값을 이용하는 것입니다.
- 중앙값을 샘플하고 계산하는 추가 비용이 따르겠지만, 대부분의 경우 3개의 샘플을 선택하고 그 중간 항목으로 분할할 때 개선 효과를 볼 수 있다는 것이 알려져 있습니다.
![[Pasted image 20250809151733.png]]
#### 엔트로피 최적 정렬
- 많은 수의 중복된 키를 가진 배열은 실제 응용 상황에서 자주 등장합니다.
	- 예를 들어 많은 수의 개인 정보 파일을 생일 또는 성별을 기준으로 정렬해야 하는 경우가 그렇습니다.
- 이런 경우에도 퀵 정렬이 여전히 수용할 만한 성능을 보여주지만, 아주 큰 개선의 여지가 있습니다.
	- 예를 들어, 한 가지 키만 가진 부분 배열이라면 더 이상 처리할 필요가 없음에도 퀵 정렬은 계속해서 분할을 수행합니다.

- 한 가지 직접적인 개선 아이디어 중 하나는 분할을 세 부분으로 하는 것입니다.
	- 분할 기준 항목의 키값보다 작은 부분, 같은 부분, 큰 부분으로 나눕니다.
- 이는 약간 더 복잡해질 수 있지만, 다익스트라에 의해 유명해진 고전적 문제, 삼색 네덜란드 국기 문제를 응용할 수 있습니다.

![[03_040_3WayPartitioningOverview]]

- 이 문제에 대한 해법은 굉장히 단순한 분할 코드로 만들어집니다.
	- 왼쪽에서 오른쪽으로 한 번의 배열 순회를 합니다.
	- 이때 세 가지 조건, a\[lo..lt-1] < v와, a\[gt+1..hi] > v 그리고 a\[lt..i-1] == v가 만족되도록 포인터 lt와 gt를 관리합니다.
		- 이 조건에서 a\[i..gt] 부분은 아직 검사되지 않은 상태입니다.
	- i를 lo부터 시작하여 앞의 세 가지 조건으로 a\[i]를 처리합니다.
		- a\[i]가 v보다 작다: a\[lt]와 a\[i]를 서로 교환하고 lt와 i를 증가시킨다.
		- a\[i]가 v보다 크다: a\[i]와 a\[gt]를 서로 교환하고 gt를 감소시킨다.
		- a\[i]가 v와 같다: i를 증가시킨다.

![[03_050_3WayPartitioningTrace]]

#### 코드: 3-Way Partitioning Quick Sort

```c++
void sort_internal(T arr[], int low, int high)
{
	// 기저 사례: 배열 크기가 1 이하이면 종료
	if (high <= low)
	{
		return;
	}

	// 3-way 파티셔닝을 위한 포인터와 피벗 설정
	int lt = low;       // 피벗보다 작은 부분의 끝
	int i = low + 1;    // 현재 탐색 위치
	int gt = high;      // 피벗보다 큰 부분의 시작
	T pivot = arr[low];

	// 파티셔닝 루프: i 포인터가 gt 포인터를 넘어설 때까지 반복
	while (i <= gt)
	{
		if (arr[i] < pivot)
		{
			// arr[i]가 피벗보다 작으면 lt 섹션으로 보냄
			this->swap(arr, lt++, i++);
		}
		else if (arr[i] > pivot)
		{
			// arr[i]가 피벗보다 크면 gt 섹션으로 보냄
			// i는 증가시키지 않음 (바꿔온 gt 위치의 값을 다시 확인해야 함)
			this->swap(arr, i, gt--);
		}
		else // arr[i] == pivot
		{
			// arr[i]가 피벗과 같으면 i만 증가시켜 피벗 섹션에 포함
			i++;
		}
	}

	// 파티셔닝 후, 3개의 부분으로 나뉨:
	// arr[low..lt-1] < pivot = arr[lt..gt] < arr[gt+1..high]

	// 피벗보다 작은 부분과 큰 부분을 재귀적으로 정렬
	sort_internal(arr, low, lt - 1);
	sort_internal(arr, gt + 1, high);
}
```

![[Pasted image 20250809151754.png]]
### 성능 특성

- (생략)
- 3중 퀵 정렬은 중복 키가 매우 많은 경우, 실행 시간을 선형 로그에서 선형으로 줄여줍니다.

- 세심하게 튜닝된 퀵 정렬은 거의 대부분의 컴퓨터와 응용 환경에서 그 어떤 비교 기반 정렬 방법보다 훨씬 더 빠릅니다.
- 하지만 이것이 정렬 알고리즘 개발의 끝은 아닙니다. 
	- 왜냐하면 비교 연산을 전혀 이용하지 않고서 정렬 알고리즘을 개발할 수도 있기 때문입니다.
	- 하지만 그런 경우에도 결국 퀵 정렬의 버전 중에 더 빠른 것이 있다는 것이 보여집니다.

### 생각해보기

- 퀵 정렬이 훨씬 빠른데, 왜 Python은 병합 정렬과 삽입 정렬의 하이브리드 형태인 팀 정렬을 사용할까요?

---

####  Stable Sort (안정 정렬)

**안정 정렬**은 중복된 키(key)를 가진 원소들이 정렬 후에도 **원래의 상대적인 순서를 그대로 유지**하는 정렬 방식입니다.
- **예시**: 학생들의 `(점수, 이름)` 데이터를 **점수** 기준으로 정렬한다고 상상해 봅시다.

| 원본 데이터          |
| --------------- |
| (90, "김민준")     |
| (85, "이서아")     |
| **(90, "박도윤")** |

만약 안정 정렬을 사용하면, 점수가 90점으로 동일한 "김민준"과 "박도윤"의 순서는 원래 순서 그대로 유지됩니다.

| 안정 정렬 후         |
| --------------- |
| (85, "이서아")     |
| (90, "김민준")     |
| **(90, "박도윤")** |

- **대표적인 안정 정렬**:
    - 삽입 정렬 (Insertion Sort)
    - 병합 정렬 (Merge Sort)
    - 버블 정렬 (Bubble Sort)

---

#### Unstable Sort (불안정 정렬)

**불안정 정렬**은 중복된 키를 가진 원소들의 원래 상대적인 순서를 **유지한다고 보장하지 않습니다.** 정렬 과정에서 이 순서가 바뀔 수 있습니다.
- **예시**: 위와 동일한 학생 데이터를 불안정 정렬로 처리하면 다음과 같이 순서가 바뀔 수 있습니다.

| 불안정 정렬 후 (가능한 결과 중 하나) |
| ---------------------- |
| (85, "이서아")            |
| **(90, "박도윤")**        |
| (90, "김민준")            |
- **대표적인 불안정 정렬**:
    - 퀵 정렬 (Quick Sort)
    - 선택 정렬 (Selection Sort)
    - 힙 정렬 (Heap Sort)


단순히 숫자만 정렬할 때는 안정성이 중요하지 않습니다. 하지만 여러 기준으로 데이터를 정렬할 때 안정성은 매우 중요해집니다.
예를 들어, 엑셀에서 **(1) 이름순으로 정렬**한 뒤, **(2) 부서순으로 다시 정렬**하는 경우를 생각해 보세요.
- 만약 두 번째 '부서순' 정렬이 **안정 정렬**이라면, 같은 부서 내에서는 이전에 정렬했던 '이름순'이 그대로 유지됩니다.
- 하지만 **불안정 정렬**이라면, 같은 부서 내의 이름 순서가 뒤죽박죽될 수 있습니다.


## 퀵-셀렉트

- 어떤 배열의 값들을 정렬했을 때, k번째에 위치하는 값을 알기 위해서는 어떻게 해야 할까요?
- 단순하게는, 해당 배열을 정렬한 뒤 k번째의 값을 확인하면 될 것입니다.
	- 하지만 이는 N log N의 시간 복잡도를 가집니다.
- 퀵 정렬을 응용하여, N의 시간 만에 해당 값의 위치를 얻을 수 있습니다.

- 방법은 다음과 같습니다:
	- 퀵 정렬은, pivot의 위치를 정렬된 상태로 만들고, 양쪽에 대해 다시 재귀적으로 수행하는 것입니다.
	- 따라서, pivot의 위치는 이미 정렬된 상태의 위치이므로, 이를 기준으로 k번째 값이 어느 영역에 존재하는지 알 수 있습니다.
	- 이를 이용하여 한쪽 방향의 부분 배열만을 계속 탐색하면서 pivot이 k번째 값이 될 때까지 반복합니다.

```c++
T select(T arr[], int n, int k)
{
	if (k < 0 || k >= n)
	{
		throw std::invalid_argument(
			"k must be within the valid range of the array.");
	}

	// 최악의 경우를 피하고 평균 O(n) 성능을 보장하기 위해 배열을 섞습니다.
	unsigned seed = 
		std::chrono::system_clock::now()
		.time_since_epoch()
		.count();
	std::shuffle(
		arr, 
		arr + n, 
		std::default_random_engine(seed));

	int low = 0;
	int high = n - 1;

	// 범위를 좁혀가며 k번째 원소를 찾습니다.
	while (high > low)
	{
		int j = partition(arr, low, high);
		____
	}

	// 루프가 끝나면 low == high == k 이므로, arr[k]가 정답입니다.
	return arr[k];
}
```



