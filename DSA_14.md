
# 3. 검색

## 3.2 이진 탐색 트리 (Binary Search Tree)

- 이 섹션에서는, 연결 리스트에서의 유연한 삽입과 정렬된 배열에서의 효율적인 탐색을 결합한 심볼 테이블 구현을 살펴볼 것입니다.
    - 특히, 노드 당 **두 개** 의 링크를 사용하는 것은 (연결 리스트에서 발견되는 노드 당 하나의 링크 대신), 이진 탐색 트리 자료구조에 기반한 효율적인 심볼 테이블 구현으로 이어지며, 이는 컴퓨터 과학에서 가장 기본적인 알고리즘 중 하나로 꼽힙니다.
- 우선, 기본적인 용어를 정의하겠습니다.
    - 우리는 **null** 이거나 다른 노드에 대한 참조인 **링크(link)** 를 포함하는 **노드(node)** 로 구성된 자료구조를 다루고 있습니다.
    - **이진 트리(binary tree)** 에서는 모든 노드가 단 하나의 다른 노드에 의해서만 참조된다는 제약이 있으며, 이 노드를 **부모(parent)** 라고 부릅니다. (어떤 노드도 가리키지 않는 하나의 노드, 즉 **루트(root)** 는 예외입니다.)
    - 또한, 각 노드는 정확히 두 개의 링크를 가지는데, 이를 각각 **왼쪽(left)** 및 **오른쪽(right)** 링크라고 하며, 이들은 각각 **왼쪽 자식(left child)** 과 **오른쪽 자식(right child)** 이라 불리는 노드를 가리킵니다.
    - 링크가 노드를 가리키기는 하지만, 우리는 각 링크를 참조되는 노드가 루트가 되는 이진 트리를 가리키는 것으로 볼 수 있습니다.
![[Pasted image 20250830144833.png]]

> 따라서, 이진 트리는 **null** 링크이거나, 각각이 독립적인 이진 트리인 (서로소) **서브트리(subtree)** 를 참조하는 왼쪽 링크와 오른쪽 링크를 가진 노드로 정의할 수 있습니다.
> **이진 탐색 트리(binary search tree)** 에서, 각 노드는 **키(key)** 와 **값(value)** 도 가지며, 효율적인 검색을 지원하기 위한 순서 제약이 있습니다.

> **정의**. **이진 탐색 트리(BST)** 는 각 노드가 **비교 가능한 (Comparable) 키** (와 그에 연관된 **값**) 를 가지는 이진 트리이며, 임의의 노드에 있는 **키** 는 그 노드의 **왼쪽 서브트리** 에 있는 모든 노드의 **키** 보다 크고, 그 노드의 **오른쪽 서브트리** 에 있는 모든 노드의 **키** 보다 작다는 제약을 만족합니다.

- 우리는 노드에 **키** 를 표시하여 BST를 그리고, 노드와 **키** 를 연관 짓는 "A는 E의 왼쪽 자식이다" 와 같은 용어를 사용합니다.
    - 노드를 연결하는 선은 링크를 나타내며, **키** 와 연관된 **값** 은 노드 옆에 검은색으로 표시합니다 (문맥에 따라 **값** 은 생략될 수 있습니다).
    - 각 노드의 링크는 페이지 아래쪽에 있는 노드들과 연결되며, 맨 아래에 짧은 선분으로 표시되는 **null** 링크는 예외입니다.
- 평소와 같이, 우리의 예제는 인덱싱-테스트 클라이언트에 의해 생성된 단일 문자로 된 **키** 를 사용합니다.

![[Pasted image 20250830144850.png]]
### 기본 구현
- `알고리즘 3.3` 에서는 이 섹션 전체에서 정렬된 심볼 테이블 API를 구현하는 데 사용하는 BST 자료구조를 정의합니다.
- 우리는 이 고전적인 자료구조 정의와, 이와 관련된 `get()` (탐색) 및 `put()` (삽입) 메서드의 특징적인 구현을 고려하는 것으로 시작하겠습니다.

#### 표현 (Representation)
- 연결 리스트에서 했던 것과 마찬가지로, BST의 노드를 정의하기 위해 **비공개 중첩 클래스 (private nested class)** 를 정의합니다.
- 각 노드는 **키**, **값**, **왼쪽 링크**, **오른쪽 링크**, 그리고 **노드 카운트** 를 포함합니다 (그림에서는 노드 위에 빨간색으로 노드 카운트를 표시합니다).
    - 왼쪽 링크는 더 작은 **키** 를 가진 항목들을 위한 BST를 가리키고, 오른쪽 링크는 더 큰 **키** 를 가진 항목들을 위한 BST를 가리킵니다.
- 인스턴스 변수 `N` 은 해당 노드를 루트로 하는 서브트리의 노드 개수를 나타냅니다.
    - 앞으로 보게 될 것처럼, 이 필드는 다양한 정렬된 심볼 테이블 연산의 구현을 용이하게 합니다.
    - `알고리즘 3.3` 의 비공개 `size()` 메서드는 **null** 링크에 값 0을 할당하도록 구현되어, 트리의 모든 노드 x에 대해 `size(x) = size(x.left) + size(x.right) + 1` 이라는 불변식이 유지되도록 보장합니다.
- BST는 **키** (와 연관된 **값**) 의 **집합(set)** 을 나타내며, 동일한 **집합** 을 나타내는 서로 다른 BST가 많이 존재할 수 있습니다.
- 만약 각 노드의 왼쪽 서브트리에 있는 모든 **키** 가 해당 노드의 **키** 왼쪽에 나타나고, 오른쪽 서브트리에 있는 모든 **키** 가 해당 노드의 **키** 오른쪽에 나타나도록 BST의 **키** 들을 투영 (project) 한다면, 우리는 항상 정렬된 순서의 **키** 들을 얻게 됩니다.
- 우리는 동일한 정렬 순서를 나타내는 많은 BST를 가질 수 있다는 고유의 유연성을 활용하여, BST를 구축하고 사용하는 효율적인 알고리즘을 개발합니다.


![[Pasted image 20250830175530.png]]

#### 탐색 (Search)
- 평소와 같이, 심볼 테이블에서 **키** 를 탐색할 때 우리는 두 가지 가능한 결과 중 하나를 얻게 됩니다.
    - 만약 **키** 를 포함하는 노드가 테이블에 있으면, **탐색 히트(search hit)** 가 되고, 우리는 그에 연관된 **값** 을 반환합니다.
    - 그렇지 않으면, **탐색 실패(search miss)** 가 되며 `null` 을 반환합니다.
- BST에서 **키** 를 찾기 위한 재귀 알고리즘은 재귀적인 구조로부터 바로 도출됩니다:
    - 만약 트리가 비어있으면 **탐색 실패** 입니다; 만약 탐색 **키** 가 루트의 **키** 와 같다면 **탐색 히트** 입니다.
    - 그렇지 않다면, 탐색 **키** 가 더 작으면 왼쪽으로, 더 크면 오른쪽으로 이동하여 적절한 서브트리에서 (재귀적으로) 탐색을 계속합니다.
- 재귀적인 `get()` 메서드는 이 알고리즘을 직접 구현합니다.
    - 이 메서드는 트리의 루트와 탐색 **키** 에서 시작하여, 첫 번째 인자로 노드(서브트리의 루트)를, 두 번째 인자로 **키** 를 받습니다.
    - 이 코드는 현재 노드를 루트로 하는 서브트리 외의 다른 어떤 부분에도 탐색 **키** 와 동일한 **키** 를 가진 노드가 있을 수 없다는 **불변식(invariant)** 을 유지합니다.
- 이진 탐색에서 각 반복마다 간격의 크기가 약 절반으로 줄어드는 것처럼, BST에서 탐색할 때 현재 노드를 루트로 하는 서브트리의 크기는 트리를 따라 내려갈수록 줄어듭니다 (이상적으로는 약 절반씩, 하지만 적어도 하나씩은 줄어듭니다).
- 이 절차는 탐색 **키** 를 포함하는 노드를 찾았을 때 (**탐색 히트**) 또는 현재 서브트리가 비어있을 때 (**탐색 실패**) 중단됩니다.
- 맨 위에서 시작하여, 각 노드에서의 탐색 절차는 해당 노드의 자식 중 하나에 대한 재귀 호출을 포함하므로, 탐색은 트리를 통과하는 하나의 **경로(path)** 를 정의합니다.
    - **탐색 히트** 의 경우, 경로는 **키** 를 포함하는 노드에서 끝납니다.
    - **탐색 실패** 의 경우, 경로는 **null** 링크에서 끝납니다.

![[Pasted image 20250830181656.png]]


#### 삽입 (Insert)
- `알고리즘 3.3` 의 탐색 코드는 이진 탐색만큼이나 간단하며, 이러한 단순성은 BST의 본질적인 특징입니다.
- BST의 더 중요한 본질적인 특징은 `insert` 가 `search` 보다 구현하기에 훨씬 더 어렵지 않다는 것입니다.
- 실제로, 트리에 없는 **키** 에 대한 탐색은 **null** 링크에서 끝나게 되며, 우리가 해야 할 일은 그 링크를 **키** 를 포함하는 새로운 노드로 교체하는 것 뿐입니다 (다음 페이지의 다이어그램 참조).
- `알고리즘 3.3` 의 재귀적인 `put()` 메서드는 재귀 탐색에 사용했던 것과 유사한 로직을 사용하여 이 작업을 수행합니다:
    - 만약 트리가 비어있으면, **키** 와 **값** 을 포함하는 새로운 노드를 반환합니다.
    - 만약 탐색 **키** 가 루트의 **키** 보다 작으면, 왼쪽 서브트리에 **키** 를 삽입한 결과를 왼쪽 링크로 설정합니다.
    - 그렇지 않으면, 오른쪽 서브트리에 **키** 를 삽입한 결과를 오른쪽 링크로 설정합니다.
![[Pasted image 20250830182006.png]]


#### 재귀 (Recursion)
- 이러한 재귀 구현의 동역학을 이해하는 데 시간을 투자할 가치가 있습니다.
- 재귀 호출 **이전** 의 코드는 트리를 **내려가면서** 발생하는 것으로 생각할 수 있습니다: 주어진 **키** 를 각 노드의 **키** 와 비교하고 그에 따라 오른쪽이나 왼쪽으로 이동합니다.
- 그런 다음, 재귀 호출 **이후** 의 코드는 트리를 **거슬러 올라가면서** 발생하는 것으로 생각할 수 있습니다.
    - `get()` 의 경우 이는 일련의 반환문에 해당하지만, `put()` 의 경우에는 탐색 경로에 있는 각 부모의 링크를 자식에게 재설정하고, 경로를 따라 올라가면서 카운트를 증가시키는 것에 해당합니다.
- 단순한 BST에서는 맨 아래에 있는 링크 하나만 새로 생기지만, 경로의 더 높은 곳에 있는 링크들을 재설정하는 것은 그것들을 설정하지 않도록 하는 테스트만큼이나 쉽습니다.
- 또한, 우리는 경로에 있는 각 노드의 노드 카운트만 증가시키면 되지만, 각 노드의 카운트를 1에 서브트리의 카운트 합을 더한 값으로 설정하는 더 일반적인 코드를 사용합니다.
- 이 섹션의 뒷부분과 다음 섹션에서는, 동일한 재귀 구조로 자연스럽게 표현되지만 탐색 경로에서 더 많은 링크를 변경할 수 있고 더 일반적인 노드 카운트 업데이트 코드가 필요한 고급 알고리즘들을 공부할 것입니다.
- 기본적인 BST는 종종 비재귀적인 코드로 구현되지만 (연습문제 3.2.12 참조), 우리는 코드가 설명된 대로 작동한다는 것을 스스로 쉽게 납득하고 더 정교한 알고리즘을 위한 기반을 마련하기 위해 구현에 재귀를 사용합니다.

### BST의 성장 과정
- 다음에 나오는 표준 인덱싱 클라이언트에 대한 추적을 **주의 깊게 연구하면** 이진 탐색 트리가 성장하는 방식에 대한 감을 잡을 수 있을 것입니다.
- 새로운 노드는 트리의 맨 아래에 있는 **null** 링크에 붙으며, 그 외의 트리 구조는 변경되지 않습니다.
- 예를 들어, 루트는 첫 번째로 삽입된 **키** 를 가지고, 루트의 자식 중 하나는 두 번째로 삽입된 **키** 를 가지는 식입니다.
- 각 노드는 두 개의 링크를 가지고 있기 때문에, 트리는 단순히 아래로만 자라는 것이 아니라 옆으로 퍼져나가는 경향이 있습니다.
- 더욱이, 루트에서부터 찾거나 삽입하려는 **키** 까지의 경로에 있는 **키** 들만 검사되므로, 트리 크기가 커질수록 검사되는 **키** 의 수는 트리에 있는 전체 **키** 수의 점점 더 작은 부분이 됩니다.

![[Pasted image 20250830182124.png]]


### 분석 (Analysis)
- 이진 탐색 트리 알고리즘의 실행 시간은 트리의 모양에 따라 달라지며, 이는 다시 **키** 가 삽입되는 순서에 따라 달라집니다.
- **최선의 경우(best case)**, `N` 개의 노드를 가진 트리는 완벽하게 균형을 이룰 수 있으며, 루트와 각 **null** 링크 사이에는 약 `lg N` 개의 노드가 있습니다.
- **최악의 경우(worst case)**, 탐색 경로에 `N` 개의 노드가 있을 수 있습니다.
- **일반적인 경우(typical case)** 의 트리 균형은 최악의 경우보다 최선의 경우에 훨씬 더 가까운 것으로 나타났습니다.
- 많은 애플리케이션에서 다음과 같은 간단한 모델이 합리적입니다: 우리는 **키** 가 (균등하게) **무작위(random)** 라고 가정하거나, 동일하게는, 무작위 순서로 삽입된다고 가정합니다.
- 이 모델의 분석은 BST가 **퀵 정렬(quicksort)과 쌍대(dual)** 라는 관찰에서 비롯됩니다.
    - 트리의 루트에 있는 노드는 퀵 정렬의 첫 번째 분할 항목에 해당하며 (왼쪽에는 더 큰 **키** 가 없고, 오른쪽에는 더 작은 **키** 가 없음), 서브트리는 퀵 정렬의 재귀적인 하위 배열 정렬에 해당하여 재귀적으로 구축됩니다.
- 이 관찰은 우리를 트리의 속성 분석으로 이끌어 줍니다.

> **명제 C**. `N` 개의 무작위 **키** 로 만들어진 BST에서의 **탐색 히트(Search hits)** 는 평균적으로 `~2 ln N` (약 `1.39 lg N`) 번의 비교를 필요로 합니다.
> **증명**
> - 주어진 노드에서 끝나는 **탐색 히트** 에 사용되는 비교 횟수는 `1 + 깊이(depth)` 입니다.
> - 모든 노드의 깊이를 더하면, 트리의 **내부 경로 길이(internal path length)** 로 알려진 양을 얻게 됩니다.
> - 따라서, 원하는 양은 BST의 평균 내부 경로 길이에 1을 더한 값이며, 이는 `섹션 2.3` 의 `명제 K` 에서 사용했던 것과 동일한 논리로 분석할 수 있습니다.
> - `N` 개의 무작위로 정렬된 고유한 **키** 를 삽입하여 만들어진 BST의 총 내부 경로 길이를 `C_N` 이라고 합시다. 그러면 **탐색 히트** 의 평균 비용은 $1 + C_N / N$ 입니다.
> - 우리는 $C_0 = C_1 = 0$ 이고, `N > 1` 에 대해 재귀적인 BST 구조를 직접적으로 반영하는 다음과 같은 점화식을 작성할 수 있습니다:
> $$C_N​=N−1+(C_0​+C_{N−1}​)/N+(C_1​+C_{N−2}))/N+...+(C_{N−1}​+C_0​)/N$$
> - `N - 1` 항은 루트가 트리의 다른 `N - 1` 개 노드 각각의 경로 길이에 1씩 기여한다는 것을 설명합니다; 나머지 표현식은 `N` 가지 크기 중 하나일 가능성이 동일한 서브트리들을 설명합니다.
> - 항들을 재배열하면, 이 점화식은 `섹션 2.3` 에서 퀵 정렬에 대해 풀었던 것과 거의 동일하며, 근사치 `C_N ~ 2N ln N` 을 유도할 수 있습니다.

---

> **명제 D**. `N` 개의 무작위 **키** 로 만들어진 BST에서의 **삽입(Insertions)** 과 **탐색 실패(search misses)** 는 평균적으로 `~2 ln N` (약 `1.39 lg N`) 번의 비교를 필요로 합니다.
> **증명
> - **삽입** 과 **탐색 실패** 는 평균적으로 **탐색 히트** 보다 한 번 더 많은 비교를 수행합니다.
> - 이 사실은 귀납법으로 어렵지 않게 증명할 수 있습니다.


#### 명제 C와 D의 의의
- `명제 C` 는 무작위 **키** 에 대한 BST 탐색 비용이 이진 탐색보다 약 39% 더 높을 것으로 예상해야 함을 말해줍니다.
- `명제 D` 는 그 추가 비용이 충분한 가치가 있다고 말합니다. 왜냐하면 새로운 **키** 를 삽입하는 비용 또한 로그 함수적일 것으로 예상되기 때문입니다.
    - 이는 정렬된 배열에서의 이진 탐색에서는 사용할 수 없는 유연성이며, 여기서 삽입에 필요한 배열 접근 횟수는 일반적으로 선형적입니다.
- 퀵 정렬과 마찬가지로, 비교 횟수의 표준 편차는 낮은 것으로 알려져 있으므로, 이 공식들은 `N` 이 증가함에 따라 점점 더 정확해집니다.

---
### 실험 (Experiments)

- 우리의 무작위-키 모델은 일반적인 심볼 테이블 클라이언트에서 발견되는 것과 얼마나 잘 일치할까요?
- 평소와 같이, 이 질문은 성능에 큰 잠재적 편차가 있기 때문에 특정 실제 응용 프로그램에 대해 신중하게 연구되어야 합니다.
- 다행히도, 많은 클라이언트에서 이 모델은 BST에 대해 상당히 잘 들어맞습니다.
- 길이가 8 이상인 단어에 대한 `FrequencyCounter` 의 `put()` 연산 비용에 대한 우리의 예제 연구에서, `BinarySearchST` 의 경우 작업 당 평균 484회의 배열 접근 또는 비교 비용이 BST의 경우 13회로 감소하는 것을 볼 수 있으며, 이는 이론적 모델이 예측한 로그 함수적 성능을 다시 한번 빠르게 검증해 줍니다.
- 더 큰 입력에 대한 더 광범위한 실험은 다음 페이지의 표에 설명되어 있습니다.
- `명제 C` 와 `D` 를 기반으로, 이 숫자는 테이블 크기의 자연 로그의 약 두 배가 되어야 한다고 예측하는 것이 합리적입니다. 왜냐하면 연산의 대부분이 거의 꽉 찬 테이블에서의 탐색이기 때문입니다.
- 이 예측에는 적어도 다음과 같은 내재된 부정확성이 있습니다:
    - 많은 연산이 더 작은 테이블에 대한 것입니다.
    - **키** 들이 무작위가 아닙니다.
    - 테이블 크기가 `2 ln N` 근사가 정확하기에는 너무 작을 수 있습니다.
- 그럼에도 불구하고, 표에서 볼 수 있듯이 이 예측은 우리의 `FrequencyCounter` 테스트 케이스에 대해 몇 번의 비교 이내로 정확합니다.
- 실제로, 대부분의 차이는 근사치의 수학을 정교하게 다듬음으로써 설명될 수 있습니다.
![[Pasted image 20250830192302.png]]

![[Pasted image 20250830192314.png]]

---
### 순서 기반 메소드와 삭제

- BST 가 널리 사용되는 중요한 이유는 **키 (key)** 를 **순서대로** 유지할 수 있게 해주기 때문입니다.
- 따라서, BST 는 클라이언트가 단순히 키를 제공하는 것뿐만 아니라 상대적인 키 순서에 의해서도 키-값 쌍에 접근할 수 있도록 하는, 우리의 순서화된 심볼 테이블 API (366 페이지 참조) 에 있는 수많은 메소드들을 구현하기 위한 기반이 될 수 있습니다.
- 다음으로, 우리는 순서화된 심볼 테이블 API 의 다양한 메소드들의 구현에 대해 고려해 보겠습니다.
#### 최소값과 최대값

> - 만약 루트의 왼쪽 링크가 `null` 이면, BST 에서 가장 작은 키는 루트에 있는 키입니다.
> - 만약 왼쪽 링크가 `null` 이 아니라면, BST 에서 가장 작은 키는 왼쪽 링크가 참조하는 노드를 루트로 하는 서브트리에서 가장 작은 키입니다.

- 이 설명은 재귀적인 `min()` 메소드에 대한 설명인 동시에, 그것이 BST 에서 가장 작은 키를 찾는다는 것에 대한 귀납적 증명입니다.
- 이 계산은 간단한 반복 ( `null` 링크를 찾을 때까지 왼쪽으로 이동 ) 과 동일하지만, 우리는 일관성을 위해 재귀를 사용합니다.
- 우리는 재귀 메소드가 **Node** 대신 **Key** 를 반환하도록 할 수도 있지만, 나중에는 최소 키를 포함하는 **Node** 에 접근하기 위해 이 메소드를 사용해야 할 필요가 있을 것입니다.
- 최대 키를 찾는 것도 비슷하며, 왼쪽 대신 오른쪽으로 이동하면 됩니다.
#### Floor와 ceiling
> - 주어진 키가 BST 의 루트에 있는 키보다 작다면, 해당 키의 `floor` (BST 에서 키보다 작거나 같은 가장 큰 키) 는 반드시 왼쪽 서브트리에 있어야 합니다.
> 
- 만약 키가 루트의 키보다 크다면, 해당 키의 `floor` 는 오른쪽 서브트리에 있을 수 있지만, 이는 오직 오른쪽 서브트리에 키보다 작거나 같은 키가 존재할 경우에만 해당됩니다.
    - 그렇지 않거나 (또는 키가 루트의 키와 같다면), 루트의 키가 바로 해당 키의 `floor` 가 됩니다.
- 다시 말해, 이 설명은 재귀적인 `floor()` 메서드의 기초가 되며, 동시에 원하는 결과를 계산한다는 귀납적 증명의 기반이 됩니다.
- 오른쪽과 왼쪽 (그리고 '보다 작음'과 '보다 큼') 을 서로 바꾸면 `ceiling()` 을 얻을 수 있습니다.
![[Pasted image 20250831203604.png]]
#### Selection
- BST 에서의 선택 (Selection) 은 우리가 2.5절에서 공부했던 배열에서의 파티션 기반 선택 방법과 유사한 방식으로 작동합니다.
- 우리는 이 연산을 정확하게 지원하기 위해, BST 노드에 해당 노드를 루트로 하는 서브트리의 키 개수를 세는 변수 N 을 유지합니다.
- 우리가 순위가 k 인 키 (정확히 k 개의 다른 키들이 더 작은 키) 를 찾는다고 가정해 봅시다.
    - 만약 왼쪽 서브트리의 키 개수 t 가 k 보다 크다면, 우리는 왼쪽 서브트리에서 순위가 k 인 키를 (재귀적으로) 찾습니다.
    - 만약 t 가 k 와 같다면, 우리는 루트의 키를 반환합니다.
    - 그리고 만약 t 가 k 보다 작다면, 우리는 오른쪽 서브트리에서 순위가 k−t−1 인 키를 (재귀적으로) 찾습니다.
- 평소와 같이, 이 설명은 다음 페이지에 있는 재귀적인 `select()` 메서드의 기초가 되며, 예상대로 작동한다는 귀납적 증명의 기반이 됩니다.
![[Pasted image 20250831203926.png]]
#### Rank
- 주어진 키의 순위 (rank) 를 반환하는 역 메서드 `rank()` 는 다음과 유사합니다:
    - 만약 주어진 키가 루트의 키와 같다면, 우리는 왼쪽 서브트리에 있는 키의 개수 t 를 반환합니다.
    - 만약 주어진 키가 루트의 키보다 작다면, 우리는 왼쪽 서브트리에서 해당 키의 순위를 (재귀적으로 계산하여) 반환합니다.
    - 그리고 만약 주어진 키가 루트의 키보다 크다면, 우리는 t 에 1 (루트의 키를 세기 위함) 을 더하고, 오른쪽 서브트리에서 해당 키의 순위를 (재귀적으로 계산하여) 더한 값을 반환합니다.

#### 최소/최대값 삭제

- 구현하기 가장 어려운 BST 연산은 심볼 테이블에서 키-값 쌍을 제거하는 `delete()` 메서드입니다.
- 준비 운동으로, 가장 작은 키를 가진 키-값 쌍을 제거하는 `deleteMin()` 을 생각해 봅시다.
- `put()` 과 마찬가지로, 우리는 노드에 대한 링크를 인자로 받아 노드에 대한 링크를 반환하는 재귀 메서드를 작성하여, 그 결과를 인자로 사용된 링크에 할당함으로써 트리의 변경사항을 반영할 수 있습니다.
- `deleteMin()` 의 경우, 왼쪽 링크가 `null` 인 노드를 찾을 때까지 왼쪽으로 이동한 다음, 해당 노드를 가리키는 링크를 그 노드의 오른쪽 링크로 교체합니다 (재귀 메서드에서 단순히 오른쪽 링크를 반환함으로써).
- 삭제된 노드는 이제 아무런 링크도 가리키지 않으므로 **가비지 컬렉션**의 대상이 됩니다.
- 우리의 표준적인 재귀 구조는 삭제 작업 후에, 부모 노드의 링크를 적절하게 설정하고 루트로 가는 경로에 있는 모든 노드의 카운트를 업데이트하는 작업을 수행합니다.
- 대칭적인 방법으로 `deleteMax()` 를 구현할 수 있습니다.

![[Pasted image 20250831203935.png]]

### 삭제
- 자식이 하나이거나 없는 노드는 비슷한 방식으로 삭제를 진행할 수 있지만, 자식이 두 개인 노드를 삭제하려면 어떻게 해야 할까요?
    - 우리에게는 두 개의 링크가 남지만, 부모 노드에는 그중 하나만을 위한 공간만 있습니다.
- 1962년 T. Hibbard 가 처음 제안한 이 딜레마에 대한 해답은, 노드 `x` 를 그 노드의 **후임자 (successor)** 로 교체하여 삭제하는 것입니다.
- `x` 는 오른쪽 자식을 가지고 있으므로, 그 후임자는 `x` 의 오른쪽 서브트리에서 가장 작은 키를 가진 노드입니다.
- `x.key` 와 후임자의 키 사이에는 다른 키가 존재하지 않기 때문에, 이 교체 작업은 트리의 순서를 보존합니다.
- 우리는 다음의 간단한 단계로 `x` 를 그 후임자로 교체하는 작업을 완료할 수 있습니다:
    > - `x`의 후임자를 찾습니다. (`min()`을 이용)
    > - `x`의 키와 값을 후임자의 키와 값으로 대체합니다.
    > - `x`의 오른쪽 자식에서 `delete_min()`을 수행합니다. 후임자는 왼쪽 자식이 없을 것이므로 후임자를 삭제하는 것은 단순한 일입니다.
    

- 우리의 표준적인 재귀 구조는 재귀 호출 후에 부모 노드의 적절한 링크를 설정하고, 루트로 가는 경로에 있는 노드들의 노드 카운트를 감소시키는 작업을 수행합니다.
    - (다시 말해, 탐색 경로에 있는 각 노드의 카운트를 자식 노드들의 카운트 합에 1을 더한 값으로 설정하여 카운트 업데이트 작업을 수행합니다).
- 이 방법은 제 역할을 수행하지만, 일부 실제 상황에서 성능 문제를 일으킬 수 있는 **결함**이 있습니다.
- 문제는 후임자를 사용하는 선택이 임의적이고 **대칭적이지 않다**는 것입니다.
- 왜 **전임자 (predecessor)** 는 사용하지 않을까요?
- 실제로는 전임자와 후임자 사이에서 **무작위로 선택**하는 것이 바람직합니다.

#### 범위 질의 (Range queries)

- 주어진 범위 내의 키들을 반환하는 `keys()` 메서드를 구현하기 위해, 우리는 **중위 순회 (inorder traversal)** 라고 알려진 기본적인 재귀적 BST 순회 메서드로 시작합니다.
- 이 방법을 설명하기 위해, BST 의 모든 키를 순서대로 출력하는 작업을 고려해 봅시다.
- 그렇게 하려면, 먼저 왼쪽 서브트리의 모든 키를 출력하고 (BST 의 정의에 따라 루트의 키보다 작음), 그 다음 루트의 키를 출력하고, 마지막으로 오른쪽 서브트리의 모든 키를 출력합니다 (BST 의 정의에 따라 루트의 키보다 큼).
- 특정 범위 내의 키를 반환하는, 두 개의 인자를 받는 `keys()` 메서드를 구현하기 위해, 우리는 이 코드를 수정하여 범위 내에 있는 각 키를 큐 (Queue) 에 추가하고, 범위 내의 키를 포함할 수 없는 서브트리에 대한 재귀 호출은 건너뜁니다.
- `BinarySearchST` 에서와 마찬가지로, 우리가 키를 큐에 모은다는 사실은 클라이언트에게 숨겨집니다.
- 클라이언트가 `Iterable<Key>` 를 구현하기 위해 우리가 어떤 자료구조를 사용하는지 알 필요 없이, Java 의 `foreach` 구문 (C++ 에서는 **range-based for loop** 에 해당) 을 사용하여 관심 범위의 모든 키를 처리하도록 하는 것이 의도입니다.

----
#### 분석
- BST 에서 순서 기반 연산들은 얼마나 효율적일까요?
    - 이 질문을 연구하기 위해, 우리는 **트리 높이** (트리에 있는 모든 노드의 최대 깊이) 를 고려합니다.
- 트리가 주어지면, 그 높이가 모든 BST 연산의 최악의 경우 비용을 결정합니다 (단, 범위 검색은 반환되는 키의 수에 비례하는 추가 비용이 발생하므로 예외입니다).

> **명제 E.** BST 에서 모든 연산은 최악의 경우 트리 높이에 비례하는 시간이 걸립니다.
> **증명:** 이 모든 메서드들은 트리에서 하나 또는 두 개의 경로를 따라 내려갑니다. 정의에 따라, 어떤 경로의 길이도 높이보다 길지 않습니다.

- 우리는 트리 높이 (최악의 경우 비용) 가 이전에 정의한 평균 내부 경로 길이 (짧은 경로도 평균에 포함됨) 보다 높을 것으로 예상하지만, 얼마나 더 높을까요?
    - 이 질문은 **명제 C** 와 **명제 D** 에서 답한 질문과 비슷해 보일 수 있지만, 답하기가 훨씬 더 어려우며, 확실히 이 책의 범위를 벗어납니다.
- 무작위 키로 만들어진 BST 의 평균 높이는 1979년 J. Robson 에 의해 로그 함수에 비례한다는 것이 증명되었고, 이후 L. Devroye 는 큰 N 에 대해 그 값이 2.99lgN 에 가까워진다는 것을 보여주었습니다.
- 따라서, 만약 우리 애플리케이션의 삽입이 **무작위-키 모델**로 잘 설명된다면, 우리는 이 모든 연산을 로그 시간 내에 지원하는 심볼 테이블 구현을 개발하려는 목표에 순조롭게 다가가고 있는 것입니다.
- 무작위 키로 만들어진 트리에서는 어떤 경로도 3lgN 보다 길지 않을 것으로 예상할 수 있지만, 만약 키가 무작위가 아니라면 어떻게 될까요?
- 다음 섹션에서는, 키가 삽입되는 순서에 관계없이 BST 높이가 로그 함수에 비례함을 보장하는 **균형 잡힌 BST (balanced BSTs)** 때문에 이 질문이 실제로는 논의할 실익이 없는지 알게 될 것입니다.

----

- **요약하자면**, BST 는 구현하기 어렵지 않으며, 키 삽입이 **무작위-키 모델**에 의해 잘 근사되는 경우 모든 종류의 실제 애플리케이션에 대해 빠른 검색 및 삽입을 제공할 수 있습니다.
- 우리가 든 예제 (그리고 많은 실제 애플리케이션) 에서 BST 는 주어진 작업을 수행할 수 있느냐 없느냐의 차이를 만듭니다.
- 더욱이, 많은 프로그래머들은 BST 가 빠른 순위, 선택, 삭제 및 범위 질의 연산도 지원하기 때문에 심볼 테이블 구현을 위해 BST 를 선택합니다.
- 그럼에도 불구하고, 우리가 강조했듯이 BST 의 나쁜 **최악의 경우 성능**은 일부 상황에서는 용납되지 않을 수 있습니다.
- 기본 BST 구현의 좋은 성능은 트리에 긴 경로가 많이 포함될 가능성이 없도록 키가 무작위 키와 충분히 유사한지에 달려 있습니다.
- 퀵 정렬에서는 입력을 무작위화할 수 있었지만, 심볼 테이블 API 에서는 클라이언트가 연산의 조합을 제어하기 때문에 그러한 자유가 없습니다.
- 실제로, 최악의 경우 동작은 실제로 드물지 않습니다.
    - 이는 클라이언트가 키를 순서대로 또는 역순으로 삽입할 때 발생하며, 이는 명시적인 경고가 없는 한 일부 클라이언트가 시도할 수 있는 연산 시퀀스입니다.
- 이러한 가능성이 바로 우리가 다음에 고려할 더 나은 알고리즘과 자료구조를 찾는 주된 이유입니다.

![[Pasted image 20250831210352.png]]